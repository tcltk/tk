# This file is a Tcl script to test out the "photo" image type and the other
# procedures in the file tkImgPhoto.c. It is organized in the standard fashion
# for Tcl tests.
#
# Copyright © 1994 The Australian National University
# Copyright © 1994-1997 Sun Microsystems, Inc.
# Copyright © 1998-1999 Scriptics Corporation.
# Copyright © 2002-2008 Donal K. Fellows
# All rights reserved.
#
# Author: Paul Mackerras (paulus@cs.anu.edu.au)

#
# This file is somewhat caothic: the order of the tests does not
# really follow the order of the corresponding functions in
# tkImgPhoto.c. Probably, because early versions had only a few tests
# and over time test cases were added in bits and pieces.
# To be noted, also, that this file is not complete: large portions of
# code in tkImgPhoto.c have no test coverage.
#
# To help keeping the overview, the table below lists where to find
# tests for each of the functions in tkImgPhoto.c. The function are
# listed in the order as they appear in the source file.
#

#
# Function name                         Tests for function
#--------------------------------------------------------------------------
# PhotoFormatThreadExitProc             no tests
# Tk_Create*PhotoImageFormat            no tests
# ImgPhotoCreate                        imgPhoto-2.*
# ImgPhotoCmd                           imgPhoto-4.*, imgPhoto-17.*
# GetExtension:                         no tests
# ParseSubcommandOptions:               imgPhoto-1.*
# ImgPhotoConfigureModel:              imgPhoto-3.*, imgPhoto-15.*
# toggleComplexAlphaIfNeeded:           no tests
# ImgPhotoDelete:                       imgPhoto-8.*
# ImgPhotoCmdDeleteProc:                imgPhoto-9.*
# ImgPhotoSetSize:                      no tests
# MatchFileFormat:                      imgPhoto-18.*
# MatchSringFormat:                     imgPhoto-19.*
# Tk_FindPhoto:                         imgPhoto-11.*
# Tk_PhotoPutBlock:                     imgPhoto-10.*, imgPhoto-16.*
# Tk_PhotoPutZoomedBlock:               imgPhoto-12.*
# Tk_DitherPhoto:                       no tets
# Tk_PhotoBlank:                        no tests
# Tk_PhotoExpand:                       no tests
# Tk_PhotoGetSize:                      no tests
# Tk_PhotoSetSize:                      no tests
# TkGetPhotoValidRegion:                no tests
# ImgGetPhoto:                          no tests
# Tk_PhotoGetImage                      no tests
# ImgPostscriptPhoto                    no tests
# Tk_PhotoGetMetadata:                  imgPhoto-21.*
# Tk_PhotoSetMetadata:                  imgPhoto-22.*
#--------------------------------------------------------------------------
#

#
# Some tests are not specific to a function in tkImgPhoto.c. They are:
#

#
# Test name(s)          Description
#--------------------------------------------------------------------------
# imgPhoto-5.*          Do not really belong to this file. ImgPhotoGet and
#                       ImgPhotoFree are defined in tkImgPhInstance.c.
# imgPhoto-6.*          Do not really belong to this file. ImgPhotoDisplay
#                       is defined in tkImgPhInstance.c.
# imgPhoto-7.*          Do not really belong to this file. ImgPhotoFree is
#                       defined in tkImgPhInstance.c.
# imgPhoto-13.*         Tests for separation in different interpreters
# imgPhoto-14.*         Test GIF format. Would belong to imgGIF.test
#                       - which does not exist.
#

package require tcltest 2.2
namespace import ::tcltest::*
tcltest::configure {*}$argv
tcltest::loadTestedCommands

#
# Used for imgPhoto-4.65 - imgPhoto-4.73
#
proc foreachPixel {img xVar yVar script} {
    upvar 1 $xVar x $yVar y
    set width [image width $img]
    set height [image height $img]
    for {set x 0} {$x<$width} {incr x} {
	for {set y 0} {$y<$height} {incr y} {
	    uplevel 1 $script
	}
    }
}
proc checkImgTrans {img} {
    set result {}
    foreachPixel $img x y {
	if {[$img transparency get $x $y]} {
	    lappend result $x,$y
	}
    }
    return $result
}
proc checkImgTransLoop {img script1 script2} {
    set result {}
    foreachPixel $img x y {
	eval $script1
	lappend result {*}[checkImgTrans $img]
	append result :
	eval $script2
	lappend result {*}[checkImgTrans $img]
	append result .
    }
    return $result
}

imageInit
set README [makeFile {
    README -- Tk test suite design document.
} README-imgPhoto]

set teapotPhotoFile [file join [file dirname [info script]] teapot.ppm]
set transpTeapotPhotoFile [file join [file dirname [info script]] teapotTransparent.png]

testConstraint needsTcl867 [package vsatisfies [package provide Tcl] 8.6.7-]


test imgPhoto-1.1 {options for photo images} -body {
    image create photo photo1 -width 79 -height 83
    list [photo1 cget -width] [photo1 cget -height] \
	[image width photo1] [image height photo1]
} -cleanup {
    image delete photo1
} -result {79 83 79 83}
test imgPhoto-1.2 {options for photo images} -body {
    list [catch {image create photo photo1 -file no.such.file} err] \
	[string tolower $err]
} -result {1 {couldn't open "no.such.file": no such file or directory}}
test imgPhoto-1.3 {options for photo images} -body {
    image create photo photo1 -file $teapotPhotoFile -format no.such.format
} -returnCodes error -result {image file format "no.such.format" is not supported}
test imgPhoto-1.4 {options for photo images} -body {
    image create photo photo1 -file $teapotPhotoFile
    list [image width photo1] [image height photo1]
} -cleanup {
    image delete photo1
} -result {256 256}
test imgPhoto-1.5 {options for photo images} -body {
    image create photo photo1 -file $teapotPhotoFile \
	-format ppm -width 79 -height 83
    list [image width photo1] [image height photo1] [photo1 cget -file] [photo1 cget -format]
} -cleanup {
    image delete photo1
} -result [list 79 83 $teapotPhotoFile ppm]
test imgPhoto-1.6 {options for photo images} -body {
    image create photo photo1 -palette 2/2/2 -gamma 2.2
    list [format %.1f [photo1 cget -gamma]] [photo1 cget -palette]
} -cleanup {
    image delete photo1
} -result {2.2 2/2/2}
test imgPhoto-1.7 {options for photo images} -returnCodes error -body {
    image create photo photo1 -file $README
} -result [subst {couldn't recognize data in image file "$README"}]
test imgPhoto-1.8 {options for photo images} -body {
    image create photo -blah blah
} -returnCodes error -result {unknown option "-blah"}
test imgPhoto-1.9 {options for photo images - error case} -body {
    image create photo -format
} -returnCodes error -result {value for "-format" missing}
test imgPhoto-1.10 {options for photo images - error case} -body {
    image create photo -data
} -returnCodes error -result {value for "-data" missing}
test imgPhoto-1.11 {options for photo images - error case} -body {
    image create photo photo1 -format
} -returnCodes error -result {value for "-format" missing}
test imgPhoto-1.12 {option -alpha, normal use} -setup {
    image create photo photo1
} -body {
    photo1 put "white" -to 0 0
    photo1 transparency get 0 0 -alpha
} -cleanup {
    imageCleanup
} -result 255
test imgPhoto-1.13 {option -withalpha, normal use} -setup {
    image create photo photo1
} -body {
    photo1 put {{blue green}}
    photo1 get 1 0 -withalpha
} -cleanup {
    imageCleanup
} -result {0 128 0 255}
test imgPhoto-1.14 {options for photo images - error case} -body {
    image create photo photo1 -metadata
} -returnCodes error -result {value for "-metadata" missing}

test imgPhoto-2.1 {ImgPhotoCreate procedure} -setup {
    imageCleanup
} -body {
    catch {image create photo -blah blah}
    imageNames
} -result {}
test imgPhoto-2.2 {ImgPhotoCreate procedure} -setup {
    imageCleanup
} -body {
    image create photo image1
    list [info commands image1] [imageNames] \
	[image width image1] [image height image1]
} -cleanup {
    image delete image1
} -result {image1 image1 0 0}
# test imgPhoto-2.3 {ImgPhotoCreate procedure: creation failure} {
#     image create photo photo1
#     image create photo photo2 -width 10 -height 10
#     catch {image create photo photo2 -file bogus.img} msg
#     photo1 copy photo2
#     set msg
# } {couldn't open "bogus.img": no such file or directory}

test imgPhoto-3.1 {ImgPhotoConfigureModel procedure} -body {
    image create photo photo1 -file $teapotPhotoFile
    photo1 configure -file $teapotPhotoFile
} -cleanup {
    image delete photo1
} -result {}
test imgPhoto-3.2 {ImgPhotoConfigureModel procedure} -body {
    image create photo photo1 -file $teapotPhotoFile
    list [catch {photo1 configure -file bogus} err] [string tolower $err] \
	[image width photo1] [image height photo1]
} -cleanup {
    image delete photo1
} -result {1 {couldn't open "bogus": no such file or directory} 256 256}
test imgPhoto-3.3 {ImgPhotoConfigureModel procedure} -setup {
    destroy .c
    pack [canvas .c]
    update
} -body {
    image create photo photo1
    .c create image 10 10 -image photo1 -tags photo1.1 -anchor nw
    .c create image 300 10 -image photo1 -tags photo1.2 -anchor nw
    update
    photo1 configure -file $teapotPhotoFile
    update
    list [image width photo1] [image height photo1] [.c bbox photo1.1] [.c bbox photo1.2]
} -cleanup {
    destroy .c
    image delete photo1
} -result {256 256 {10 10 266 266} {300 10 556 266}}
test imgPhoto-3.4 {ImgPhotoConfigureModel: -data <ppm>} -setup {
    image create photo photo1 -file $teapotPhotoFile
    image create photo photo2
} -body {
    photo2 configure -data [photo1 data -format ppm -from 100 100 120 120]
    list [image width photo2] [image height photo2]
} -cleanup {
    imageCleanup
} -result {20 20}
# This testcase fails with Tcl < 8.6.7, due to [25842c]
test imgPhoto-3.5 {ImgPhotoConfigureModel: -data <png>} -constraints {
    needsTcl867
} -setup {
    image create photo photo1 -file $teapotPhotoFile
    image create photo photo2
} -body {
    photo2 configure -data [photo1 data -format png -from 120 120 140 140]
    list [image width photo2] [image height photo2]
} -cleanup {
    imageCleanup
} -result {20 20}
test imgPhoto-3.6 {ImgPhotoConfigureModel: -data <default>} -setup {
    image create photo photo1 -file $teapotPhotoFile
    image create photo photo2
} -body {
    photo2 configure -data [photo1 data -from 80 90 100 110]
    list [image width photo2] [image height photo2]
} -cleanup {
    imageCleanup
} -result {20 20}

test imgPhoto-4.1 {ImgPhotoCmd procedure} -setup {
    image create photo photo1
} -body {
    photo1
} -returnCodes error -cleanup {
    image delete photo1
} -result {wrong # args: should be "photo1 option ?arg ...?"}
test imgPhoto-4.2 {ImgPhotoCmd procedure} -setup {
    image create photo photo1
} -body {
    photo1 blah
} -returnCodes error -cleanup {
    image delete photo1
} -match glob -result {bad option "blah": must be *}
test imgPhoto-4.3 {ImgPhotoCmd procedure: blank option} -setup {
    image create photo photo1
} -body {
    photo1 blank
    photo1 blank x
} -cleanup {
    image delete photo1
} -returnCodes error -result {wrong # args: should be "photo1 blank"}
test imgPhoto-4.4 {ImgPhotoCmd procedure: cget option} -setup {
    image create photo photo1
} -body {
    photo1 cget
} -cleanup {
    image delete photo1
} -returnCodes error -result {wrong # args: should be "photo1 cget option"}
test imgPhoto-4.5 {ImgPhotoCmd procedure: cget option} -setup {
    image create photo photo2 -width 25 -height 30
} -body {
    list [photo2 cget -width] [photo2 cget -height]
} -cleanup {
    image delete photo2
} -result {25 30}
test imgPhoto-4.6 {ImgPhotoCmd procedure: configure option} -setup {
    image create photo photo1
} -body {
    llength [photo1 configure]
} -cleanup {
    image delete photo1
} -result 8
test imgPhoto-4.7 {ImgPhotoCmd procedure: configure option} -setup {
    image create photo photo1
} -body {
    photo1 conf -palette 3/4/2
    photo1 configure -palette
} -cleanup {
    image delete photo1
} -result {-palette {} {} {} 3/4/2}
test imgPhoto-4.8 {ImgPhotoCmd procedure: configure option} -setup {
    image create photo photo1
} -body {
    photo1 configure -blah
} -cleanup {
    image delete photo1
} -returnCodes error -result {unknown option "-blah"}
test imgPhoto-4.9 {ImgPhotoCmd procedure: configure option} -setup {
    image create photo photo1
} -body {
    photo1 configure -palette {} -gamma
} -cleanup {
    image delete photo1
} -returnCodes error -result {value for "-gamma" missing}
test imgPhoto-4.10 {ImgPhotoCmd procedure: copy option} -setup {
    image create photo photo1
    image create photo photo2 -width 25 -height 30
} -body {
    image create photo photo2 -file $teapotPhotoFile
    photo1 configure -width 0 -height 0 -palette {} -gamma 1
    photo1 copy photo2
    list [image width photo1] [image height photo1] [photo1 get 100 100]
} -cleanup {
    image delete photo1 photo2
} -result {256 256 {169 117 90}}
test imgPhoto-4.11 {ImgPhotoCmd procedure: copy option} -setup {
    image create photo photo1
} -body {
    photo1 copy
} -returnCodes error -cleanup {
    image delete photo1
} -result {wrong # args: should be "photo1 copy source-image ?-compositingrule rule? ?-from x1 y1 x2 y2? ?-to x1 y1 x2 y2? ?-zoom x y? ?-subsample x y?"}
test imgPhoto-4.12 {ImgPhotoCmd procedure: copy option} -setup {
    image create photo photo1
} -body {
    photo1 copy blah
} -returnCodes error -cleanup {
    image delete photo1
} -result {image "blah" doesn't exist or is not a photo image}
test imgPhoto-4.13 {ImgPhotoCmd procedure: copy option} -setup {
    image create photo photo1
    image create photo photo2
} -body {
    photo1 copy photo2 -blah
} -returnCodes error -cleanup {
    image delete photo1 photo2
} -result {unrecognized option "-blah": must be -compositingrule, -from, -shrink, -subsample, -to, or -zoom}
test imgPhoto-4.14 {ImgPhotoCmd procedure: copy option} -setup {
    image create photo photo1
    image create photo photo2
} -body {
    photo1 copy photo2 -from -to
} -returnCodes error -cleanup {
    image delete photo1 photo2
} -result {the "-from" option requires one to four integer values}
test imgPhoto-4.15 {ImgPhotoCmd procedure: copy option} -setup {
    image create photo photo1
    image create photo photo2 -file $teapotPhotoFile
} -body {
    photo1 copy photo2
    photo1 copy photo2 -from 0 70 60 120 -shrink
    list [image width photo1] [image height photo1] [photo1 get 20 10]
} -cleanup {
    image delete photo1 photo2
} -result {60 50 {215 154 120}}
test imgPhoto-4.16 {ImgPhotoCmd procedure: copy option} -setup {
    image create photo photo1
    image create photo photo2 -file $teapotPhotoFile
} -body {
    photo1 copy photo2 -from 60 120 0 70 -to 20 50
    list [image width photo1] [image height photo1] [photo1 get 40 80]
} -cleanup {
    image delete photo1 photo2
} -result {80 100 {19 92 192}}
test imgPhoto-4.17 {ImgPhotoCmd procedure: copy option} -setup {
    image create photo photo1
    image create photo photo2 -file $teapotPhotoFile
} -body {
    photo1 copy photo2 -from 0 120 60 70 -to 0 0 100 100
    list [image width photo1] [image height photo1] [photo1 get 80 60]
} -cleanup {
    image delete photo1 photo2
} -result {100 100 {215 154 120}}
test imgPhoto-4.18 {ImgPhotoCmd procedure: copy option} -setup {
    image create photo photo1
    image create photo photo2 -file $teapotPhotoFile
} -body {
    photo1 copy photo2 -from 60 70 0 120 -zoom 2
    list [image width photo1] [image height photo1] [photo1 get 100 50]
} -cleanup {
    image delete photo1 photo2
} -result {120 100 {169 99 47}}
test imgPhoto-4.19 {ImgPhotoCmd procedure: copy option} -setup {
    image create photo photo1
    image create photo photo2 -file $teapotPhotoFile
} -body {
    photo1 copy photo2 -from 0 70 60 120 -zoom 2
    list [image width photo1] [image height photo1] [photo1 get 100 50]
} -cleanup {
    image delete photo1 photo2
} -result {120 100 {169 99 47}}
test imgPhoto-4.20 {ImgPhotoCmd procedure: copy option} -setup {
    image create photo photo1
    image create photo photo2 -file $teapotPhotoFile
} -body {
    photo1 copy photo2 -from 20 20 200 180 -subsample 2 -shrink
    list [image width photo1] [image height photo1] [photo1 get 50 30]
} -cleanup {
    image delete photo1 photo2
} -result {90 80 {207 146 112}}
test imgPhoto-4.21 {ImgPhotoCmd procedure: copy option} -setup {
    image create photo photo1
    image create photo photo2 -file $teapotPhotoFile
} -body {
    photo1 copy photo2
    set result [list [image width photo1] [image height photo1]]
    photo1 conf -width 49 -height 51
    lappend result [image width photo1] [image height photo1]
    photo1 copy photo2
    lappend result [image width photo1] [image height photo1]
    photo1 copy photo2 -from 0 0 10 10 -shrink
    lappend result [image width photo1] [image height photo1]
    photo1 conf -width 0
    photo1 copy photo2 -from 0 0 10 10 -shrink
    lappend result [image width photo1] [image height photo1]
    photo1 conf -height 0
    photo1 copy photo2 -from 0 0 10 10 -shrink
    lappend result [image width photo1] [image height photo1]
} -cleanup {
    image delete photo1 photo2
} -result {256 256 49 51 49 51 49 51 10 51 10 10}
# tests for <imageName> data: imgPhoto-4.
test imgPhoto-4.22 {ImgPhotoCmd procedure: get option} -setup {
    image create photo photo1
} -body {
    photo1 read $transpTeapotPhotoFile
    list [photo1 get 100 100 -withalpha] \
	[photo1 get 150 100 -withalpha] \
	[photo1 get 100 150] [photo1 get 150 150]
} -cleanup {
    image delete photo1
} -result {{175 71 0 162} {179 73 0 168} {14 8 0} {0 0 0}}
test imgPhoto-4.23 {ImgPhotoCmd procedure: get option} -setup {
    image create photo photo1
} -body {
    photo1 get 256 0
} -cleanup {
    image delete photo1
} -returnCodes error -result {photo1 get: coordinates out of range}
test imgPhoto-4.24 {ImgPhotoCmd procedure: get option} -setup {
    image create photo photo1
} -body {
    photo1 get 0 -1
} -cleanup {
    image delete photo1
} -returnCodes error -result {photo1 get: coordinates out of range}
test imgPhoto-4.25 {ImgPhotoCmd procedure: get option} -setup {
    image create photo photo1
} -body {
    photo1 get 0
} -cleanup {
    image delete photo1
} -returnCodes error -result \
    {wrong # args: should be "photo1 get x y ?-withalpha?"}
# more test for image get: 4.101-4.102
test imgPhoto-4.26 {ImgPhotoCmd procedure: put option} -setup {
    image create photo photo1
} -body {
    photo1 put
} -returnCodes error -cleanup {
    image delete photo1
} -result {wrong # args: should be "photo1 put data ?-option value ...?"}
test imgPhoto-4.27 {ImgPhotoCmd procedure: put option} -setup {
    image create photo photo1
} -body {
    photo1 put {{white} {white white}}
} -returnCodes error -cleanup {
    image delete photo1
} -result {invalid row # 1: all rows must have the same number of elements}
test imgPhoto-4.28 {ImgPhotoCmd procedure: put option} -setup {
    image create photo photo1
} -body {
    photo1 put {{blahgle}}
} -cleanup {
    image delete photo1
} -returnCodes error -result {invalid color name "blahgle"}
test imgPhoto-4.29 {ImgPhotoCmd procedure: put option} -setup {
    image create photo photo1
} -body {
    # SB: odd thing - this test passed with tk 8.6.6, even if the data
    # is in the wrong position:
    #photo1 put -to 10 10 20 20 {{white}}

    # this is how it's supposed to be:
    photo1 put {{white}} -to 10 10 20 20
    photo1 get 19 19
} -cleanup {
    image delete photo1
} -result {255 255 255}
# more tests for image put: 4.90-4.100
test imgPhoto-4.30 {ImgPhotoCmd procedure: read option} -setup {
    image create photo photo1
} -body {
    photo1 read
} -returnCodes error -cleanup {
    image delete photo1
} -result {wrong # args: should be "photo1 read fileName ?-option value ...?"}
test imgPhoto-4.31 {ImgPhotoCmd procedure: read option} -setup {
    image create photo photo1
} -body {
    photo1 read $teapotPhotoFile -zoom 2
} -returnCodes error -cleanup {
    image delete photo1
} -result {unrecognized option "-zoom": must be -format, -from, -metadata, -shrink, or -to}
test imgPhoto-4.32 {ImgPhotoCmd procedure: read option} -setup {
    image create photo photo1
} -body {
    list [catch {photo1 read bogus} err] [string tolower $err]
} -cleanup {
    image delete photo1
} -result {1 {couldn't open "bogus": no such file or directory}}
test imgPhoto-4.33 {ImgPhotoCmd procedure: read option} -setup {
    image create photo photo1
} -body {
    photo1 read $teapotPhotoFile -format bogus
} -cleanup {
    image delete photo1
} -returnCodes error -result {image file format "bogus" is not supported}
test imgPhoto-4.34 {ImgPhotoCmd procedure: read option} -setup {
    image create photo photo1
} -body {
    photo1 read $README
} -returnCodes error -cleanup {
    image delete photo1
} -result [subst {couldn't recognize data in image file "$README"}]
test imgPhoto-4.35 {ImgPhotoCmd procedure: read option} -setup {
    image create photo photo1
} -body {
    photo1 read $teapotPhotoFile
    list [image width photo1] [image height photo1] [photo1 get 120 120]
} -cleanup {
    image delete photo1
} -result {256 256 {161 109 82}}
test imgPhoto-4.36 {ImgPhotoCmd procedure: read option} -setup {
    image create photo photo1
} -body {
    photo1 read $teapotPhotoFile -from 0 70 60 120 -to 10 10 -shrink
    list [image width photo1] [image height photo1] [photo1 get 29 19]
} -cleanup {
    image delete photo1
} -result {70 60 {244 180 144}}
test imgPhoto-4.37 {ImgPhotoCmd procedure: redither option} -setup {
    image create photo photo1
} -body {
    photo1 redither
    photo1 redither x
} -cleanup {
    image delete photo1
} -returnCodes error -result {wrong # args: should be "photo1 redither"}
test imgPhoto-4.38 {ImgPhotoCmd procedure: write option} -setup {
    image create photo photo1
} -body {
    photo1 write
} -returnCodes error -cleanup {
    image delete photo1
} -result {wrong # args: should be "photo1 write fileName ?-option value ...?"}
test imgPhoto-4.39 {ImgPhotoCmd procedure: write option} -setup {
    image create photo photo1
} -body {
    photo1 write teapot.tmp -format bogus
} -cleanup {
    image delete photo1
} -returnCodes error -result {image file format "bogus" is unknown}
# more tests on "imageName write": imgPhoto-17.*
test imgPhoto-4.40 {ImgPhotoCmd procedure: transparency option} -setup {
    image create photo photo1
} -body {
    photo1 transparency
} -returnCodes error -cleanup {
    image delete photo1
} -result {wrong # args: should be "photo1 transparency option ?arg ...?"}
test imgPhoto-4.41 {ImgPhotoCmd procedure: transparency get option} -setup {
    image create photo photo1
} -body {
    photo1 transparency get
} -returnCodes error -cleanup {
    image delete photo1
} -result {wrong # args: should be "photo1 transparency get x y ?-option?"}
test imgPhoto-4.42 {ImgPhotoCmd procedure: transparency get option} -setup {
    image create photo photo1
} -body {
    photo1 transparency get 0
} -returnCodes error -cleanup {
    image delete photo1
} -result {wrong # args: should be "photo1 transparency get x y ?-option?"}
test imgPhoto-4.43 {ImgPhotoCmd procedure: transparency get option} -setup {
    image create photo photo1
} -body {
    photo1 transparency get 0 0 0 -alpha
} -returnCodes error -cleanup {
    image delete photo1
} -result {wrong # args: should be "photo1 transparency get x y ?-option?"}
test imgPhoto-4.44 {ImgPhotoCmd procedure: transparency get option} -setup {
    image create photo photo1
} -body {
    photo1 transparency get bogus 0
} -cleanup {
    image delete photo1
} -returnCodes error -result {expected integer but got "bogus"}
test imgPhoto-4.45 {ImgPhotoCmd procedure: transparency get option} -setup {
    image create photo photo1
} -body {
    photo1 transparency get 0 bogus
} -cleanup {
    image delete photo1
} -returnCodes error -result {expected integer but got "bogus"}
test imgPhoto-4.46 {ImgPhotoCmd procedure: transparency get option} -setup {
    image create photo photo1
} -body {
    photo1 put white
    photo1 transparency get 0 0
} -cleanup {
    image delete photo1
} -result 0
test imgPhoto-4.47 {ImgPhotoCmd procedure: transparency get option} -setup {
    image create photo photo1
} -body {
    photo1 transparency get 1 0
} -returnCodes error -cleanup {
    image delete photo1
} -result {photo1 transparency get: coordinates out of range}
test imgPhoto-4.48 {ImgPhotoCmd procedure: transparency get option} -setup {
    image create photo photo1
} -body {
    photo1 transparency get -1 0
} -returnCodes error -cleanup {
    image delete photo1
} -result {photo1 transparency get: coordinates out of range}
test imgPhoto-4.49 {ImgPhotoCmd procedure: transparency get option} -setup {
    image create photo photo1
} -body {
    photo1 transparency get 0 1
} -returnCodes error -cleanup {
    image delete photo1
} -result {photo1 transparency get: coordinates out of range}
test imgPhoto-4.50 {ImgPhotoCmd procedure: transparency get option} -setup {
    image create photo photo1
} -body {
    photo1 transparency get 0 -1
} -returnCodes error -cleanup {
    image delete photo1
} -result {photo1 transparency get: coordinates out of range}
test imgPhoto-4.51 {ImgPhotoCmd procedure: transparency get option} -setup {
    image create photo photo1
} -body {
    photo1 put white
    photo1 blank
    photo1 transparency get 0 0
} -cleanup {
    image delete photo1
} -result 1
# more tests for transparency get: 4.65, 4.66, 4.76-4.81
test imgPhoto-4.52 {ImgPhotoCmd procedure: transparency set option} -setup {
    image create photo photo1
} -body {
    photo1 transparency set
} -returnCodes error -cleanup {
    image delete photo1
} -result \
    {wrong # args: should be "photo1 transparency set x y newVal ?-option?"}
test imgPhoto-4.53 {ImgPhotoCmd procedure: transparency set option} -setup {
    image create photo photo1
} -body {
    photo1 transparency set 0
} -returnCodes error -cleanup {
    image delete photo1
} -result \
    {wrong # args: should be "photo1 transparency set x y newVal ?-option?"}
test imgPhoto-4.54 {ImgPhotoCmd procedure: transparency set option} -setup {
    image create photo photo1
} -body {
    photo1 transparency set 0 0
} -returnCodes error -cleanup {
    image delete photo1
} -result \
    {wrong # args: should be "photo1 transparency set x y newVal ?-option?"}
test imgPhoto-4.55 {ImgPhotoCmd procedure: transparency set option} -setup {
    image create photo photo1
} -body {
    photo1 transparency set 0 0 0 0 -alpha
} -returnCodes error -cleanup {
    image delete photo1
} -result \
    {wrong # args: should be "photo1 transparency set x y newVal ?-option?"}
test imgPhoto-4.56 {ImgPhotoCmd procedure: transparency set option} -setup {
    image create photo photo1
} -body {
    photo1 transparency set bogus 0 0
} -cleanup {
    image delete photo1
} -returnCodes error -result {expected integer but got "bogus"}
test imgPhoto-4.57 {ImgPhotoCmd procedure: transparency set option} -setup {
    image create photo photo1
} -body {
    photo1 transparency set 0 bogus 0
} -cleanup {
    image delete photo1
} -returnCodes error -result {expected integer but got "bogus"}
test imgPhoto-4.58 {ImgPhotoCmd procedure: transparency set option} -setup {
    image create photo photo1
    photo1 put blue
} -body {
    photo1 transparency set 0 0 bogus
} -cleanup {
    image delete photo1
} -returnCodes error -result {expected boolean value but got "bogus"}
test imgPhoto-4.59 {ImgPhotoCmd procedure: transparency set option} -setup {
    image create photo photo1
} -body {
    photo1 transparency set 1 0 0
} -returnCodes error -cleanup {
    image delete photo1
} -result {photo1 transparency set: coordinates out of range}
test imgPhoto-4.60 {ImgPhotoCmd procedure: transparency set option} -setup {
    image create photo photo1
} -body {
    photo1 transparency set -1 0 0
} -returnCodes error -cleanup {
    image delete photo1
} -result {photo1 transparency set: coordinates out of range}
test imgPhoto-4.61 {ImgPhotoCmd procedure: transparency set option} -setup {
    image create photo photo1
} -body {
    photo1 transparency set 0 1 0
} -returnCodes error -cleanup {
    image delete photo1
} -result {photo1 transparency set: coordinates out of range}
test imgPhoto-4.62 {ImgPhotoCmd procedure: transparency set option} -setup {
    image create photo photo1
} -body {
    photo1 transparency set 0 -1 0
} -returnCodes error -cleanup {
    image delete photo1
} -result {photo1 transparency set: coordinates out of range}
test imgPhoto-4.63 {ImgPhotoCmd procedure: transparency set option} -setup {
    image create photo photo1
} -body {
    photo1 put white
    photo1 transparency set 0 0 false
    photo1 transparency get 0 0
} -cleanup {
    image delete photo1
} -result 0
test imgPhoto-4.64 {ImgPhotoCmd procedure: transparency set option} -setup {
    image create photo photo1
} -body {
    photo1 put white
    photo1 transparency set 0 0 true
    photo1 transparency get 0 0
} -cleanup {
    image delete photo1
} -result 1
# more tests for transparency set: 4.67, 4.68, 4.82-4.89
# Now for some heftier testing, checking that setting and resetting of pixels'
# transparency status doesn't "leak" with any one-off errors.
test imgPhoto-4.65 {ImgPhotoCmd procedure: transparency get option} -setup {
    image create photo photo1
} -body {
    photo1 put white -to 0 0 3 3
    checkImgTrans photo1
} -cleanup {
    image delete photo1
} -result {}
test imgPhoto-4.66 {ImgPhotoCmd procedure: transparency get option} -setup {
    image create photo photo1
} -body {
    photo1 put white -to 0 0 3 3
    photo1 blank
    checkImgTrans photo1
} -result {0,0 0,1 0,2 1,0 1,1 1,2 2,0 2,1 2,2}
test imgPhoto-4.67 {ImgPhotoCmd procedure: transparency set option} -setup {
    image create photo photo1
} -body {
    photo1 put white -to 0 0 3 3
    checkImgTransLoop photo1 {
	photo1 put white -to 0 0 3 3
	photo1 transparency set $x $y 1
    } {
	photo1 transparency set $x $y 0
    }
} -cleanup {
    image delete photo1
} -result {0,0:. 0,1:. 0,2:. 1,0:. 1,1:. 1,2:. 2,0:. 2,1:. 2,2:.}
test imgPhoto-4.68 {ImgPhotoCmd procedure: transparency set option} -setup {
    image create photo photo1
} -body {
    photo1 put white -to 0 0 3 3
    checkImgTransLoop photo1 {
	photo1 blank
	photo1 transparency set $x $y 0
    } {
	photo1 transparency set $x $y 1
    }
} -cleanup {
    image delete photo1
} -result {0,1 0,2 1,0 1,1 1,2 2,0 2,1 2,2: 0,0 0,1 0,2 1,0 1,1 1,2 2,0 2,1 2,2. 0,0 0,2 1,0 1,1 1,2 2,0 2,1 2,2: 0,0 0,1 0,2 1,0 1,1 1,2 2,0 2,1 2,2. 0,0 0,1 1,0 1,1 1,2 2,0 2,1 2,2: 0,0 0,1 0,2 1,0 1,1 1,2 2,0 2,1 2,2. 0,0 0,1 0,2 1,1 1,2 2,0 2,1 2,2: 0,0 0,1 0,2 1,0 1,1 1,2 2,0 2,1 2,2. 0,0 0,1 0,2 1,0 1,2 2,0 2,1 2,2: 0,0 0,1 0,2 1,0 1,1 1,2 2,0 2,1 2,2. 0,0 0,1 0,2 1,0 1,1 2,0 2,1 2,2: 0,0 0,1 0,2 1,0 1,1 1,2 2,0 2,1 2,2. 0,0 0,1 0,2 1,0 1,1 1,2 2,1 2,2: 0,0 0,1 0,2 1,0 1,1 1,2 2,0 2,1 2,2. 0,0 0,1 0,2 1,0 1,1 1,2 2,0 2,2: 0,0 0,1 0,2 1,0 1,1 1,2 2,0 2,1 2,2. 0,0 0,1 0,2 1,0 1,1 1,2 2,0 2,1: 0,0 0,1 0,2 1,0 1,1 1,2 2,0 2,1 2,2.}
test imgPhoto-4.69 {ImgPhotoCmd procedure: copy with -compositingrule} -setup {
    # Test the compositing rules for copying images
    image create photo photo1 -width 3 -height 3
    image create photo photo2 -width 2 -height 2
} -body {
    photo1 copy photo2 -to 1 1 -compositingrule
} -cleanup {
    image delete photo1 photo2
} -returnCodes error -result {the "-compositingrule" option requires a value}
test imgPhoto-4.70 {ImgPhotoCmd procedure: copy with -compositingrule} -setup {
    # Test the compositing rules for copying images
    image create photo photo1 -width 3 -height 3
    image create photo photo2 -width 2 -height 2
} -body {
    photo1 copy photo2 -to 1 1 -compositingrule BAD
} -returnCodes error -cleanup {
    image delete photo1 photo2
} -result {bad compositing rule "BAD": must be overlay or set}
test imgPhoto-4.71 {ImgPhotoCmd procedure: copy with -compositingrule} -setup {
    # Test the compositing rules for copying images
    image create photo photo1 -width 3 -height 3
    image create photo photo2 -width 2 -height 2
} -body {
    # Tests default compositing rule
    photo1 blank
    photo2 blank
    photo1 put white -to 0 0 2 2
    photo2 put white -to 0 0 2 2
    photo2 transparency set 0 0 true
    photo1 copy photo2 -to 1 1
    checkImgTrans photo1
} -cleanup {
    image delete photo1 photo2
} -result {0,2 2,0}
test imgPhoto-4.72 {ImgPhotoCmd procedure: copy with -compositingrule} -setup {
    # Test the compositing rules for copying images
    image create photo photo1 -width 3 -height 3
    image create photo photo2 -width 2 -height 2
} -body {
    photo1 blank
    photo2 blank
    photo1 put white -to 0 0 2 2
    photo2 put white -to 0 0 2 2
    photo2 transparency set 0 0 true
    photo1 copy photo2 -to 1 1 -compositingrule overlay
    checkImgTrans photo1
} -cleanup {
    image delete photo1 photo2
} -result {0,2 2,0}
test imgPhoto-4.73 {ImgPhotoCmd procedure: copy with -compositingrule} -setup {
    # Test the compositing rules for copying images
    image create photo photo1 -width 3 -height 3
    image create photo photo2 -width 2 -height 2
} -body {
    photo1 blank
    photo2 blank
    photo1 put white -to 0 0 2 2
    photo2 put white -to 0 0 2 2
    photo2 transparency set 0 0 true
    photo1 copy photo2 -to 1 1 -compositingrule set
    checkImgTrans photo1
} -cleanup {
    image delete photo1 photo2
} -result {0,2 1,1 2,0}
test imgPhoto-4.74 {ImgPhotoCmd procedure: put option error handling} -setup {
    image create photo photo1
} -body {
    photo1 put {{white}} -to 10 10 20 20 {{white}}
} -cleanup {
    image delete photo1
} -returnCodes 1 -result {wrong # args: should be "photo1 put data ?-option value ...?"}
test imgPhoto-4.75 {<photo> read command: filename starting with '-'} -body {
    file copy -force $teapotPhotoFile -teapotPhotoFile
    image create photo photo1
    photo1 read -teapotPhotoFile
} -cleanup {
    image delete photo1
    file delete ./-teapotPhotoFile
} -result {}
test imgPhoto-4.75.1 {ImgPhotoCmd procedure: copy to same image} -setup {
    imageCleanup
    image create photo photo1 -file $teapotPhotoFile
} -body {
    # non-regression test for bug [5239fd749b] - shall just not crash
    photo1 copy photo1 -to 0 0 2000 1000
    photo1 copy photo1 -subsample 2 2 -shrink
} -cleanup {
    imageCleanup
} -result {}
test imgPhoto-4.76 {ImgPhotoCmd, transparency get: too many options} -setup {
    image create photo photo1
} -body {
    photo1 put white -to 0 0 1 1
    photo1 transparency get 0 0 -alpha -bogus
} -cleanup {
    imageCleanup
} -returnCodes error -result \
    {wrong # args: should be "photo1 transparency get x y ?-option?"}
test imgPhoto-4.77 {ImgPhotoCmd, transparency get: invalid option} -setup {
    image create photo photo1
} -body {
    photo1 put white -to 0 0 1 1
    photo1 transparency get 0 0 -bogus
} -cleanup {
    imageCleanup
} -returnCodes error -result \
    {unrecognized option "-bogus": must be -alpha}
test imgPhoto-4.78 {ImgPhotoCmd, transparency get: normal use} -setup {
    image create photo photo1
} -body {
    photo1 put white -to 0 0 1 1
    set result [photo1 transparency get 0 0]
    lappend result [photo1 transparency get 0 0 -alpha]
} -cleanup {
    imageCleanup
} -result {0 255}
test imgPhoto-4.79 {ImgPhotoCmd, transparency get: no option} -setup {
    image create photo photo1 -file $transpTeapotPhotoFile
    set result {}
} -body {
    set pixelCoords {{156 239} {76 207} {153 213} {139 43} {75 112}}
    foreach coord $pixelCoords {
	lappend result [photo1 transparency get {*}$coord]
    }
    set result
} -cleanup {
    imageCleanup
} -result {0 1 0 0 0}
# test imgPhoto-4.80: deleted (was transparency get: -boolean)
test imgPhoto-4.81 {ImgPhotoCmd, transparency get: -alpha} -setup {
    image create photo photo1 -file $transpTeapotPhotoFile
    set result {}
} -body {
    set pixelCoords {{156 239} {76 207} {153 213} {139 43} {75 112}}
    foreach coord $pixelCoords {
	lappend result [photo1 transparency get {*}$coord -alpha]
    }
    set result
} -cleanup {
    imageCleanup
} -result {255 0 1 254 206}
test imgPhoto-4.82 {ImgPhotoCmd, transparency set: too many opts} -setup {
    image create photo photo1
} -body {
    photo1 transparency set 0 0 -alpha -bogus 1
} -cleanup {
    imageCleanup
} -returnCodes error -result \
    {wrong # args: should be "photo1 transparency set x y newVal ?-option?"}
test imgPhoto-4.83 {ImgPhotoCmd, transparency set: invalid opt} -setup {
    image create photo photo1 -data black
} -body {
    photo1 transparency set 0 0 0 -bogus
} -cleanup {
    imageCleanup
} -returnCodes error -result \
    {unrecognized option "-bogus": must be -alpha}
test imgPhoto-4.84 {ImgPhotoCmd, transparency set: invalid newVal} -setup {
    image create photo photo1 -data white
} -body {
    photo1 transparency set 0 0 bogus -alpha
} -cleanup {
    imageCleanup
} -returnCodes error -result {expected integer but got "bogus"}
test imgPhoto-4.85 {ImgPhotoCmd, transparency set: invalid newVal} -setup {
    image create photo photo1 -data red
} -body {
    photo1 transparency set 0 0 -1 -alpha
} -returnCodes error -result \
    {invalid alpha value "-1": must be integer between 0 and 255}
test imgPhoto-4.86 {ImgPhotoCmd, transparency set: invalid newVal} -setup {
    image create photo photo1 -data green
} -body {
    photo1 transparency set 0 0 256 -alpha
} -cleanup {
    imageCleanup
} -returnCodes error -result \
    {invalid alpha value "256": must be integer between 0 and 255}
test imgPhoto-4.87 {ImgPhotoCmd, transparency set: no opt} -setup {
    image create photo photo1
} -body {
    photo1 put white -to 0 0 2 1
    photo1 transparency set 0 0 0
    photo1 transparency set 1 0 1
    list [photo1 transparency get 0 0 -alpha] \
        [photo1 transparency get 1 0 -alpha]
} -cleanup {
    imageCleanup
} -result {255 0}
# deleted: test imgPhoto-4.88 {ImgPhotoCmd, transparency set: -boolean}
test imgPhoto-4.89 {ImgPhotoCmd, transparency set: -alpha} -setup {
    image create photo photo1
} -body {
    photo1 put white -to 0 0 2 2
    photo1 transparency set 0 0 0 -alpha
    photo1 transparency set 1 0 1 -alpha
    photo1 transparency set 0 1 254 -alpha
    photo1 transparency set 1 1 255 -alpha
    list [photo1 transparency get 0 0] [photo1 transparency get 1 0] \
	[photo1 transparency get 0 1] [photo1 transparency get 1 1]
} -cleanup {
    imageCleanup
} -result {1 0 0 0}
test imgPhoto-4.90 {ImgPhotoCmd put: existing but not allowed opt} -setup {
    image create photo photo1
} -body {
    photo1 put yellow -from 0 0 1 1
} -cleanup {
    imageCleanup
} -returnCodes error -result \
    {unrecognized option "-from": must be -format, -metadata, or -to}
test imgPhoto-4.91 {ImgPhotoCmd put: invalid option} -setup {
    image create photo photo1
} -body {
    photo1 put {{0 1 2 3}} -bogus x
} -returnCodes error -result \
    {unrecognized option "-bogus": must be -format, -metadata, or -to}
test imgPhoto-4.92 {ImgPhotocmd put: missing data} -setup {
    image create photo photo1
} -body {
    photo1 put -to 0 0
} -returnCodes error -result \
    {wrong # args: should be "photo1 put data ?-option value ...?"}
test imgPhoto-4.93 {ImgPhotoCmd put: data in ppm format} -setup {
    image create photo photo1 -file $teapotPhotoFile
    image create photo photo2
} -body {
    set imgdata [photo1 data -format ppm]
    photo2 put $imgdata -format ppm
    set result {}
    if {[image width photo1] != [image width photo2] \
            || [image height photo1] != [image height photo2]} {
        lappend result [list [image width photo2] [image height photo2]]
    } else {
        lappend result 1
    }
    foreach point {{206 125} {67 12} {13 46} {19 184}} {
        if {[photo1 get {*}$point] ne [photo2 get {*}$point]} {
            lappend result [photo2 get {*}$point]
        } else {
            lappend result 1
        }
    }
    set result
} -cleanup {
    imageCleanup
} -result {1 1 1 1 1}
test imgPhoto-4.94 {ImgPhotoCmd put: unknown format} -setup {
    image create photo photo1
} -body {
    photo1 put {no real data} -format bogus
} -cleanup {
    imageCleanup
} -returnCodes error -result {image format "bogus" is not supported}
test imgPhoto-4.95 {ImgPhotoCmd put: default fmt, invalid data} -setup {
    image create photo photo1
} -body {
    photo1 put {{red green blue} {red " blue}}
    #"
} -cleanup {
    imageCleanup
} -returnCodes error -result {unmatched open quote in list}
test imgPhoto-4.96 {ImgPhotoCmd put: "default" handler is selected} -setup {
    image create photo photo1
    image create photo photo2
    set imgData {{{1 2 3 4} {5 6 7 8} {9 10 11 12}}
        {{13 14 15 15} {17 18 19 20} {21 22 23 24}}}
} -body {
    photo1 put $imgData
    photo2 put $imgData -format default
    set result {}
    lappend result [list [image width photo1] [image height photo1]]
    lappend result [list [image width photo2] [image height photo2]]
    lappend result [string equal \
        [photo1 data -format "default -colorformat rgba"] \
        [photo2 data -format "default -colorformat rgba"]]
    set result
} -cleanup {
    imageCleanup
    unset result
    unset imgData
} -result {{3 2} {3 2} 1}
test imgPhoto-4.97 {ImgPhotoCmd put: image size} -setup {
    image create photo photo1
} -body {
    photo1 put {{red green blue} {blue red green}}
    list [image width photo1] [image height photo1]
} -cleanup {
    imageCleanup
} -result {3 2}
test imgPhoto-4.98 {ImgPhotoCmd put: -to with 2 coords} -setup {
    image create photo photo1
} -body {
    photo1 put {{"alice blue" "blanched almond"}
		{"deep sky blue" "ghost white"}
		{#AABBCC #AABBCCDD}} -to 5 6
    list [image width photo1] [image height photo1]
} -cleanup {
    imageCleanup
} -result {7 9}
test imgPhoto-4.99 {ImgPhotoCmd put: -to with 4 coords} -setup {
    image create photo photo1
} -body {
    photo1 put {{#123 #456 #678} {#9AB #CDE #F01}} -to 1 2 20 21
    set result {}
    lappend result [photo1 get 19 20 -withalpha]
    lappend result [string equal \
	[photo1 data -from 1 2 4 4] [photo1 data -from 4 2 7 4]]
    lappend result [string equal \
	[photo1 data -from 10 12 13 14] [photo1 data -from 16 16 19 18]]
    set result
} -cleanup {
    imageCleanup
} -result {{17 34 51 255} 1 1}
test imgPhoto-4.100 {ImgPhotoCmd put: no changes on empty data} -setup {
    image create photo photo1
} -body {
    photo1 put {{brown blue} {cyan coral}}
    set imgData [photo1 data]
    photo1 put {}
    string equal $imgData [photo1 data]
} -cleanup {
    imageCleanup
} -result 1
test imgPhoto-4.101 {ImgPhotoCmd get: too many args} -setup {
    image create photo photo1
} -body {
    photo1 get 0 0 -withalpha bogus
} -cleanup {
    imageCleanup
} -returnCodes error -result \
    {wrong # args: should be "photo1 get x y ?-withalpha?"}
test imgPhoto-4.102 {ImgPhotoCmd get: invalid option} -setup {
    image create photo photo1
} -body {
    photo1 get 0 0 -bogus
} -cleanup {
    imageCleanup
} -returnCodes error -result \
    {unrecognized option "-bogus": must be -withalpha}
test imgPhoto-4.103 {ImgPhotoCmd data: accepted opts} -setup {
    image create photo photo1 -data black
} -body {
    photo1 data -format default -from 0 0 -grayscale -background blue
} -cleanup {
    imageCleanup
} -result {{#000000}}
test imgPhoto-4.104 {ImgPhotoCmd data: existing but not accepted opt} -setup {
    image create photo photo1
} -body {
    photo1 data -to
} -cleanup {
    imageCleanup
} -returnCodes error -result \
{unrecognized option "-to": must be -background, -format, -from, -grayscale, or -metadata}
test imgPhoto-4.105 {ImgPhotoCmd data: invalid option} -setup {
    image create photo photo1
} -body {
    photo1 data -bogus
} -cleanup {
    imageCleanup
} -returnCodes error -result \
{unrecognized option "-bogus": must be -background, -format, -from, -grayscale, or -metadata}
test imgPhoto-4.106 {ImgPhotoCmd data: extra arg before options} -setup {
    image create photo photo1
} -body {
    photo1 data bogus -grayscale
} -cleanup {
    imageCleanup
} -returnCodes error -result \
    {wrong # args: should be "photo1 data ?-option value ...?"}
test imgPhoto-4.107 {ImgPhotoCmd data: extra arg after options} -setup {
    image create photo photo1
} -body {
    photo1 data -format default bogus
} -cleanup {
    imageCleanup
} -returnCodes error -result \
    {wrong # args: should be "photo1 data ?-option value ...?"}
test imgPhoto-4.108 {ImgPhotoCmd data: invalid -from coords #1} -setup {
    image create photo photo1 -data blue
} -body {
    photo1 data -from 2 0
} -cleanup {
    imageCleanup
} -returnCodes error -result \
    {coordinates for -from option extend outside image}
test imgPhoto-4.109 {ImgPhotoCmd data: invalid -from coords #2} -setup {
    image create photo photo1 -data blue
} -body {
    photo1 data -from 0 2
} -cleanup {
    imageCleanup
} -returnCodes error -result \
    {coordinates for -from option extend outside image}
test imgPhoto-4.110 {ImgPhotoCmd data: invalid -from coords #3} -setup {
    image create photo photo1 -data blue
} -body {
    photo1 data -from 0 0 2 1
} -cleanup {
    imageCleanup
} -returnCodes error -result \
    {coordinates for -from option extend outside image}
test imgPhoto-4.111 {ImgPhotoCmd data: invalid -from coords #4} -setup {
    image create photo photo1 -data blue
} -body {
    photo1 data -from 0 0 1 2
} -cleanup {
    imageCleanup
} -returnCodes error -result \
    {coordinates for -from option extend outside image}
test imgPhoto-4.112 {ImgPhotoCmd data: -from with 2 coords} -setup {
    image create photo photo1 -data {
        {black black black black black}
        {white white white white white}
        {green green green green green}}
} -body {
    set imgData [photo1 data -from 2 1]
    list [llength [lindex $imgData 0]] [llength $imgData]
} -cleanup {
    imageCleanup
    unset imgData
} -result {3 2}
test imgPhoto-4.113 {ImgPhotoCmd data: default is rgb format} -setup {
    image create photo photo1 -data red
} -body {
    photo1 data
} -cleanup {
    imageCleanup
} -result {{#ff0000}}
test imgPhoto-4.114 {ImgPhotoCmd data: unknown format} -setup {
    image create photo photo1
} -body {
    photo1 data -format bogus
} -cleanup {
    imageCleanup
} -returnCodes error -result {image string format "bogus" is unknown}
test imgPhoto-4.115 {ImgPhotoCmd data: rgb colorformat} -setup {
    image create photo photo1 -data {{red#a green#b} {blue#c white}}
} -body {
    photo1 data -format {default -colorformat rgb}
} -result {{#ff0000 #008000} {#0000ff #ffffff}}
test imgPhoto-4.116 {ImgPhotoCmd data: rgba colorformat} -setup {
    image create photo photo1 -data {{red green} {blue white}}
} -body {
    photo1 data -format {default -colorformat rgba}
} -result {{#ff0000ff #008000ff} {#0000ffff #ffffffff}}
test imgPhoto-4.117 {ImgPhotoCmd data: list colorformat} -setup {
    image create photo photo1 -data {{red#a green} {blue#c white#d}}
} -body {
    photo1 data -format {default -colorformat list}
} -result {{{255 0 0 170} {0 128 0 255}} {{0 0 255 204} {255 255 255 221}}}
# This testcase fails with Tcl < 8.6.7, due to [25842c]
test imgPhoto-4.118 {ImgPhotoCmd data: using data for new image
    results in same image as orignial } -constraints {
        needsTcl867
} -setup {
    image create photo teapot -file $teapotPhotoFile
    teapot copy teapot -from 50 60 70 80 -shrink
    image create photo teapotTransp -file $transpTeapotPhotoFile
    teapotTransp copy teapotTransp -from 100 110 120 130 -shrink
    image create photo photo1
} -body {
    set result {}
    # We don't test gif here, as there seems to be a problem with
    # <imgName> data and gif format ("too many colors", probably a bug)
    foreach fmt {ppm png {default -colorformat rgba} \
            {default -colorformat list}} {
        set imgData [teapotTransp data -format $fmt]
        photo1 blank
        photo1 put $imgData
        if { ! [string equal [photo1 data] [teapotTransp data]]} {
            lappend result $fmt
        }
    }
    set imgData [teapot data -format default]
    photo1 blank
    photo1 put $imgData
    if { ! [string equal [photo1 data] [teapot data]]} {
        lappend result default
    }
    set result
} -cleanup {
    unset imgData
    unset result
    imageCleanup
} -result {}

test imgPhoto-5.1 {ImgPhotoGet/Free procedures, shared instances} -setup {
    destroy .c
    pack [canvas .c]
    imageCleanup
} -body {
    image create photo photo1 -file $teapotPhotoFile
    .c create image 0 0 -image photo1 -tags photo1.1
    .c create image 256 0 -image photo1 -tags photo1.2
    .c create image 0 256 -image photo1 -tags photo1.3
    update
    .c delete i1.1
    photo1 configure -width 1
    update
    .c delete i1.2
    photo1 configure -height 1
    update
    image delete photo1
} -cleanup {
    destroy .c
} -result {}

test imgPhoto-6.1 {ImgPhotoDisplay procedure, blank display} -setup {
    destroy .c
    pack [canvas .c]
    imageCleanup
} -body {
    image create photo photo1 -width 10 -height 10
    photo1 blank
    .c create image 10 10 -image photo1
    update
} -cleanup {
    destroy .c
    image delete photo1
} -result {}

test imgPhoto-7.1 {ImgPhotoFree procedure, resource freeing} -setup {
    destroy .c
    pack [canvas .c]
    imageCleanup
} -body {
    image create photo photo1 -file $teapotPhotoFile
    .c create image 0 0 -image photo1 -anchor nw
    update
    .c delete all
    image delete photo1
} -cleanup {
    destroy .c
}  -result {}
test imgPhoto-7.2 {ImgPhotoFree procedures, unlinking} -setup {
    deleteWindows
    imageCleanup
} -body {
    image create photo photo1 -file $teapotPhotoFile
    pack [canvas .c]
    .c create image 10 10 -image photo1 -anchor nw
    button .b1 -image photo1
    button .b2 -image photo1
    button .b3 -image photo1
    pack .b1 .b2 .b3
    update
    destroy .b2
    update
    destroy .b3
    update
    destroy .b1
    update
    .c delete all
} -cleanup {
    destroy .c
    image delete photo1
} -result {}
test imgPhoto-7.3 {ImgPhotoFree procedures, multiple visuals} -setup {
    deleteWindows
    imageCleanup
} -body {
    image create photo photo1 -file $teapotPhotoFile
    button .b1 -image photo1
    frame .f -visual best
    button .f.b2 -image photo1
    pack .f.b2
    pack .b1 .f
    update
    destroy .b1
    update
    .f.b2 configure -image {}
    update
    destroy .f
    image delete photo1
} -result {}

test imgPhoto-8.1 {ImgPhotoDelete procedure} -body {
    image create photo photo2 -file $teapotPhotoFile
    image delete photo2
} -result {}
test imgPhoto-8.2 {ImgPhotoDelete procedure} -setup {
    set x {}
} -body {
    image create photo photo2 -file $teapotPhotoFile
    rename photo2 newphoto2
    lappend x [info command photo2] [info command new*] [newphoto2 cget -file]
    image delete photo2
    lappend x [info command new*]
} -result [list {} newphoto2 $teapotPhotoFile {}]
test imgPhoto-8.3 {ImgPhotoDelete procedure, name cleanup} -body {
    image create photo photo1
    image create photo photo2 -width 10 -height 10
    image delete photo2
    photo1 copy photo2
} -returnCodes error -cleanup {
    imageCleanup
} -result {image "photo2" doesn't exist or is not a photo image}

test imgPhoto-9.1 {ImgPhotoCmdDeletedProc procedure} -body {
    image create photo photo2 -file $teapotPhotoFile
    rename photo2 {}
    list [expr {"photo2" in [imageNames]}] [catch {photo2 foo} msg] $msg
} -result {0 1 {invalid command name "photo2"}}

test imgPhoto-10.1 {Tk_ImgPhotoPutBlock procedure} -setup {
    imageCleanup
} -body {
    image create photo photo1
    photo1 put "{#ff0000 #ff0000 #ff0000 #ff0000 #ff0000 #ff0000 #ff0000 #ff0000}" -to 0 0
    photo1 put "{#00ff00 #00ff00}" -to 2 0
    list [photo1 get 2 0] [photo1 get 3 0] [photo1 get 4 0]
} -result {{0 255 0} {0 255 0} {255 0 0}}
test imgPhoto-10.2 {Tk_ImgPhotoPutBlock, same source and dest img} -setup {
    imageCleanup
} -body {
    # Test for bug e4336bef5d
    image create photo photo1 -file $teapotPhotoFile
    image create photo photo2 -file $teapotPhotoFile
    photo2 copy photo1 -to 1 2
    photo1 copy photo1 -to 1 2
    string equal [photo1 data] [photo2 data]
} -cleanup {
    imageCleanup
} -result 1
test imgPhoto-10.3 {Tk_ImgPhotoPutBlock, same source and dest img} -setup {
    imageCleanup
} -body {
    # Test for bug e4336bef5d
    image create photo photo1 -file $teapotPhotoFile
    image create photo photo2 -file $teapotPhotoFile
    photo2 copy photo1 -from 2 1 -to 4 5 300 300
    photo1 copy photo1 -from 2 1 -to 4 5 300 300
    string equal [photo1 data] [photo2 data]
} -cleanup {
    imageCleanup
} -result 1
test imgPhoto-10.4 {Tk_ImgPhotoPutBlock, empty image} -setup {
    imageCleanup
} -body {
    image create photo photo1
    photo1 copy photo1 -to 0 5 10 20
    list [image width photo1] [image height photo1]
} -cleanup {
    imageCleanup
} -result {0 0}
test imgPhoto-11.1 {Tk_FindPhoto} -setup {
    imageCleanup
} -body {
    image create bitmap i1
    image create photo photo1
    photo1 copy i1
} -cleanup {
    imageCleanup
} -returnCodes error -result {image "i1" doesn't exist or is not a photo image}

test imgPhoto-12.1 {Tk_PhotoPutZoomedBlock} -body {
    image create photo p3 -file $teapotPhotoFile
    set result [list [p3 get 50 50] [p3 get 100 100]]
    p3 copy p3 -zoom 2
    lappend result [image width p3] [image height p3] [p3 get 100 100]
} -cleanup {
    image delete p3
} -result {{19 92 192} {169 117 90} 512 512 {19 92 192}}
test imgPhoto-12.2 {Tk_ImgPhotoPutZoomedBlock, same source and dest img} -setup {
    imageCleanup
} -body {
    # Test for bug e4336bef5d
    image create photo photo1 -file $teapotPhotoFile
    image create photo photo2 -file $teapotPhotoFile
    photo2 copy photo1 -to 0 1 200 200 -zoom 2 3
    photo1 copy photo1 -to 0 1 200 200 -zoom 2 3
    string equal [photo1 data] [photo2 data]
} -cleanup {
    imageCleanup
} -result 1
test imgPhoto-12.3 {Tk_ImgPhotoPutZoomedBlock, same source and dest img} -setup {
    imageCleanup
} -body {
    # Test for bug e4336bef5d
    image create photo photo1 -file $teapotPhotoFile
    image create photo photo2 -file $teapotPhotoFile
    photo2 copy photo1 -from 1 0 -to 4 5 300 300 -zoom 1 2
    photo1 copy photo1 -from 1 0 -to 4 5 300 300 -zoom 1 2
    string equal [photo1 data] [photo2 data]
} -cleanup {
    imageCleanup
} -result 1
test imgPhoto-12.4 {Tk_ImgPhotoPutZoomedBlock, empty image} -setup {
    imageCleanup
} -body {
    image create photo photo1
    photo1 copy photo1 -to 0 5 10 20
    list [image width photo1] [image height photo1]
} -cleanup {
    imageCleanup
} -result {0 0}
test imgPhoto-12.5 {Tk_ImgPhotoPutZoomedBlock, copy from area outside the image, bug [a0241c0e25]} -setup {
    imageCleanup
} -body {
    image create photo photo1 -width 20 -height 20
    image create photo photo2 -width 9 -height 10
    # next line used to loop for a very long time; if the bug is present
    # the CI runner will time out, leading to test suite failure
    photo2 copy photo1 -to 0 5 3 8 -from 21 0
} -cleanup {
    imageCleanup
} -returnCodes error -result {coordinates for -from option extend outside source image}

test imgPhoto-13.1 {check separation of images in different interpreters} -setup {
    imageCleanup
    set data {
	R0lGODlhQgBkAPUAANbWxs7Wxs7OxsbOxsbGxsbGvb3Gvca9vcDAwL21vbW1vbW1tbWtta2t
	ta2ltaWltaWlraWctaWcrZycrZyUrZSUrZSMrZSMpYyMrYyMpYyEpYSEpYR7pYR7nHp7pYRz
	pYRynHtzpXtznHtrnHNrnHNjnGtjnGtjlGtalGNalGNSlGNSjFpSlFpKlFpKjFJKjFJCjFI5
	jEo5jEo5hEoxhEIxhDkphDkhhAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACwAAAAAQgBkAAAG
	/kCEcEgsGo/IpHLJbDqf0Kh0Sq1ar9isdsvter/gsHhMLpvP6LR6zW673/C4fE6v2+/4vH7P
	7/v/gIGCg4SFhoeIiYqLjI2Oj5CRkpOUlZaXmJmOBZxXnAQEnKIIBUQJCguoDKkIBgWhpUev
	CA4TDwgEUpwKERUaHCIiJCQjIiEUQhwqKiwqLjDQMCwoIha3oUO5ESMuLSwtLSIMsU4Tzi4o
	JBwWFA8ODQoMCkIMq6sNDQ4UFhwlzC4qSGhgkMvCsAoM6E0oAWMCOSUFGrgQcauAgAACSqGa
	l6SAK1EaJXBA0SIDBw0KBiCg8EtEBgEWYCxoooAigFwIJGgQYQIF/goTAjk6sXhxAwwFnHRO
	mEmAwoQAIUo8lCWhRgoOElJVkJBQFCwhCRqkYlUE1QMKHEywoBCrQaeIMCgQeOCi3AkYMmRI
	S5EuxEkN7OApkGDhF4fDxoSVMAFUBAWkRxI0a+XghVAkBSqMsFCBwj4OI0igSKGCdLN0wYKd
	zGDBwUYhn6YOKUCioQECGk7INpIArQgUKkr87TyhAYIDQxQgLkYsRIcQIDjcgi2Lw8RYKaAz
	MXCgAs8UJrZGmOA5AkeQBlqRKsIpvYMQDx4S4NCCxIJSKJpFYMIgnPlSF2ygAQWuCUHAAp6x
	E4EEE5BXQQUWYLABBySoAIMLHBSBWwso/jxwIAoyzMAWEw3AEEJCt6nUwAQagCDCYcCQwJcK
	6QD3DDQxwNDCCSg9NIAGKpwwgQAOtDADDBbsdkQDIPhkwosDPgDPAg1EAME++1jTnhAKdAnb
	VAR04EIJFAhwwQs0sBDfE7cZwEAE++yU2joOtDcKE7GUcoIKH6RSmwwnQCZFKAo8cE2es7my
	HnuxKTDgAA6owEEBjoL3wqRUNDBCCnyRYMFMRSDoWYPvyBPPA738lt1KKTxgpjolrDDiFAWU
	cAMKE+CipAMRZMDTCSSUQMIJPQHLwWOcrDKBCBpokAIJgmYqQgosxIAOCS8iJEQD7HR2QbMh
	WCCEK7Ck90Cz/oAFu+YVigpTwTsLyJOcBJ6N6plxRihA3E4cOKTkFCU6FMoAA7wiygAZgURA
	ekYsEJYFGTSATRccQEMjti8eZsEFFuA7z2WkEJAAl7iEQekEhQHGzgQR4INUKLB8pYAFJaQA
	KhleKdwAByEkFswHIoxQQn4AcYBvGRosisDICCjQAIMJGnZYBsUd4JEZBIhQwgPzKFwAwggL
	IHbOQzCtxZ1NL0BlKmmhIOwwHGTg2YMUEBdtKzBfbQWlhMHoHIXBnvABBGE9UMKNMKhgQgnG
	nNQO0wVQoI4FEohFyr9GzDIYaaPxxWy0rCjKQJUMQvxBaMOgNMQChcU4DAkZ6PoV/hIUoP4i
	Z7g/YHZHIPXeyWyONgsaCi4AOoLjXP8uhAAvPpCQ2Akr38UpXW60Ij8yPkMmwwj8KAI8QWtQ
	+eXSixEb37WhcHQBERz2rdZ8leCBBcXNY3XevQ8VG/6+F5CACDYgATlmYYD27aRmLngBNADC
	GGxxQEAWUJDzqpcctc2DARN4kNRgtJxhnKAFV0kIEhYAJ34IQwUhqkENYFCCE5BmGf9wwWmA
	5UGgXAAVtfCFMIgRLMbFLQIPYFACcMI7TjQoH2eJQIs2poEMYMAp5XGAvFrBCYS9ImzQG1vT
	arGTEQhIhE7QjLA+MKDOxClGwuoJtWi0uBIUIxjDSE2wQ4iHl7ywQDjGwZws/NcAlgBjaKQJ
	JDVuoQBeUeACoFkMcFqgQL1IgxpRSsjsqHA/gy0tHvmAx2z2BxIupaJrnVxCEAAAOw==
    }
    interp create x1
    interp create x2
    x1 eval {load {} Tk}
    x2 eval {load {} Tk}
} -body {
    x1 eval [list image create photo T1_data -data $data]
    x2 eval [list image create photo T1_data -data $data]
} -cleanup {
    interp delete x1
    interp delete x2
} -result T1_data

test imgPhoto-14.1 {GIF writes work correctly} -setup {
    set data {
	R0lGODlhYwA5APcAAAAAAIAAAACAAICAAAAAgIAAgACAgICAgAysnGy8hKzM
	hASs3MTcjAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
	AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
	AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
	AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
	AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
	AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
	AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
	AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
	AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
	AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
	AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
	AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
	AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
	AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
	AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
	AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMDAwP8AAAD/
	AP//AAAA//8A/wD//////ywAAAAAYwA5AAAI/wAZCBxIsKDBgwgTKlzIsKHD
	hxAjSpxIsaLFixgzatzIsaPHjyBDihxJsqTJkyhTqlzJsqXLlzBjypxJs6bN
	mzhz6tzJs6fPn0CDCh1KtKhRiwoSKEXAtGlTpUqPGkyagOmCq1edNsWalWkC
	BUSXIuDqFepBqFWtZv3KU+zYrkrBSqT6dgECtjOTbu16NwFHvV3lshRLti/J
	qlgRCE6ZuO9ik4Dt+k0ZVyZiyVIvXr77ODPEy5g9T4zMWfTEzXdNz1VbWvXn
	uqldP1TAOrbshqBb314Y2W7n3Qdpv7UNPCHpycUVbv6dnODy5sqzQldIe8H0
	hciva9/Ovbv37+BzBgEEADs=
    }
    set tmpfilename [makeFile {} imgPhoto-14.1.gif]
    removeFile $tmpfilename
} -body {
    image create photo photo1 -data $data
    photo1 write $tmpfilename -format gif
    image create photo photo2 -file $tmpfilename
    string equal [photo1 data] [photo2 data]
} -cleanup {
    catch {image delete photo1 photo2}
    catch {file delete -force $tmpfilename}
} -result 1
test imgPhoto-14.2 {GIF -index handler buffer sizing} -setup {
    set data {
	R0lGODlhIAAgAKEAAPkOSQsi7////////yH/C05FVFNDQVBFMi4wAwEAAAAh
	+QQJMgAAACwGAAYAFAAUAAACEYyPqcvtD6OctNqLs968+68VACH5BAkyAAEA
	LAMAAwAaABoAAAI0jH+gq+gfmFzQzUsr3gBybn1gIm5kaUaoubbuC8fyTNel
	Ohv1CSO533u8KrgbUfc5Ci/EAgA7
    }
} -body {
    # Bug 1458234 makes this crash when trying to access buffers of the wrong
    # size, caused when the initial frame is not the largest frame.
    set i [image create photo]
    $i configure -data $data -format {gif -index 2}
} -cleanup {
    image delete $i
} -returnCodes error -result {no image data for this index}
test imgPhoto-14.3 {GIF -index interleaving and small frames} -body {
    # Interleaved GIFs used to crash us when a smaller subsequent frame was
    # accessed.
    set i [image create photo]
    $i configure -format {GIF -index 1} -data {
	R0lGODdhAQAFAPAAAP8AAAAAACwAAAAAAQAFAEACAoRdACwAAAAAAQAEAEACAoRRADs=
    }
} -cleanup {
    image delete $i
}
test imgPhoto-14.4 {GIF buffer overflow} -setup {
    set data {
	R0lGODlhCgAKAPcAAAAAAIAAAACAAICAAAAAgIAAgACAgICAgMDAwP8AAAD/
	AP//AAAA//8A/wD//////wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
	AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
	AAAAMwAAZgAAmQAAzAAA/wAzAAAzMwAzZgAzmQAzzAAz/wBmAABmMwBmZgBm
	mQBmzABm/wCZAACZMwCZZgCZmQCZzACZ/wDMAADMMwDMZgDMmQDMzADM/wD/
	AAD/MwD/ZgD/mQD/zAD//zMAADMAMzMAZjMAmTMAzDMA/zMzADMzMzMzZjMz
	mTMzzDMz/zNmADNmMzNmZjNmmTNmzDNm/zOZADOZMzOZZjOZmTOZzDOZ/zPM
	ADPMMzPMZjPMmTPMzDPM/zP/ADP/MzP/ZjP/mTP/zDP//2YAAGYAM2YAZmYA
	mWYAzGYA/2YzAGYzM2YzZmYzmWYzzGYz/2ZmAGZmM2ZmZmZmmWZmzGZm/2aZ
	AGaZM2aZZmaZmWaZzGaZ/2bMAGbMM2bMZmbMmWbMzGbM/2b/AGb/M2b/Zmb/
	mWb/zGb//5kAAJkAM5kAZpkAmZkAzJkA/5kzAJkzM5kzZpkzmZkzzJkz/5lm
	AJlmM5lmZplmmZlmzJlm/5mZAJmZM5mZZpmZmZmZzJmZ/5nMAJnMM5nMZpnM
	mZnMzJnM/5n/AJn/M5n/Zpn/mZn/zJn//8wAAMwAM8wAZswAmcwAzMwA/8wz
	AMwzM8wzZswzmcwzzMwz/8xmAMxmM8xmZsxmmcxmzMxm/8yZAMyZM8yZZsyZ
	mcyZzMyZ/8zMAMzMM8zMZszMmczMzMzM/8z/AMz/M8z/Zsz/mcz/zMz///8A
	AP8AM/8AZv8Amf8AzP8A//8zAP8zM/8zZv8zmf8zzP8z//9mAP9mM/9mZv9m
	mf9mzP9m//+ZAP+ZM/+ZZv+Zmf+ZzP+Z///MAP/MM//MZv/Mmf/MzP/M////
	AP//M///Zv//mf//zP///yH5BAEAABAALAAAAAAKAAoAABUSAAD/HEiwoMGD
	CBMqXMiwYcKAADs=
    }
} -body {
    # This crashes Tk up to 8.4.17 and 8.5.0
    set i [image create photo]
    $i configure -data $data
} -cleanup {
    image delete $i
} -returnCodes error -result {malformed image}
test imgPhoto-14.5 {Bug [fbaed1f66b] - GIF decoder with deferred clear code} -setup {
    set fileName [file join [file dirname [info script]] deferredClearCode.gif]
} -body {
    # This erroneously produced "malformed image" error.
    # The animated GIF "deferredClearCode.gif" has two frames, and calling for -index 2
    # simply is an easy way to trigger the problem of improper management of a deferred
    # clear code. The effect was that the GIF decoder bailed out before the end of the
    # image reading, and produced the inappropriate "malformed image error".
    image create photo -file $fileName -format "gif -index 2"
} -returnCodes error -result {no image data for this index}

test imgPhoto-14.6 {Access Subimage after Subimage with buffer overflow. Ticket 4da2191b} -setup {
    set data {
	R0lGODlhYwA5APcAAAAAAIAAAACAAICAAAAAgIAAgACAgICAgAysnGy8hKzM
	hASs3MTcjAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
	AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
	AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
	AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
	AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
	AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
	AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
	AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
	AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
	AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
	AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
	AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
	AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
	AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
	AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
	AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMDAwP8AAAD/
	AP//AAAA//8A/wD//////ywAAAAAYwA5AAAI/wAZCBxIsKDBgwgTKlzIsKHD
	hxAjSpxIsaLFixgzatzIsaPHjyBDihxJsqTJkyhTqlzJsqXLlzBjypxJs6bN
	mzhz6tzJs6fPn0CDCh1KtKhRiwoSKEXAtGlTpUqPGkyagOmCq1edNsWalWkC
	BUSXIuDqFepBqFWtZv3KU+zYrkrBSqT6dgECtjOTbu16NwFHvV3lshRLti/J
	qlgRCE6ZuO9ik4Dt+k0ZVyZiyVIvXr77ODPEy5g9T4zMWfTEzXdNz1VbWvXn
	uqldP1TAOrbshqBb314Y2W7n3Qdpv7UNPCHpycUVbv6dnODy5sqzQldIe8H0
	hciva9/Ovbv37+BzBgE7ACH5BAFkAAMALAAAAAAEAAQAAAMEKLrckgA7
    }
} -body {
    image create photo photo1 -data $data -format "GIF -index 1"
} -cleanup {
    catch {image delete photo1}
} -result photo1

test imgPhoto-15.1 {photo images can fail to allocate memory gracefully} -constraints {
    nonPortable
} -body {
    # This is not portable to very large machines with more than around 3GB of
    # free memory available...
    image create photo -width 32000 -height 32000
} -returnCodes error -result {not enough free memory for image buffer}

test imgPhoto-16.1 {copying to self doesn't access freed memory} -setup {
    set i [image create photo]
} -body {
    # Bug 877950 makes this crash when trying to copy out of a deallocated
    # area.
    $i put red -to 0 0 1000 1000
    $i copy $i -from 0 0 1000 1000 -to 500 0
} -cleanup {
    image delete $i
} -result {}

# Check that we can guess our supported output formats [Bug 2983824]
test imgPhoto-17.1 {photo write: format guessing from filename} -setup {
    set i [image create photo -width 3 -height 3]
} -body {
    set f [makeFile {} test.png]
    $i write $f
    set fd [open $f]
    seek $fd 1
    read $fd 3
} -cleanup {
    catch {close $fd}
    image delete $i
    catch {removeFile $f}
} -result PNG
test imgPhoto-17.2 {photo write: format guessing from filename} -setup {
    set i [image create photo -width 3 -height 3]
} -body {
    set f [makeFile {} test.gif]
    $i write $f
    set fd [open $f]
    read $fd 3
} -cleanup {
    catch {close $fd}
    image delete $i
    catch {removeFile $f}
} -result GIF
test imgPhoto-17.3 {photo write: format guessing from filename} -setup {
    set i [image create photo -width 3 -height 3]
} -body {
    set f [makeFile {} test.ppm]
    $i write $f
    set fd [open $f]
    read $fd 3
} -cleanup {
    catch {close $fd}
    image delete $i
    catch {removeFile $f}
} -result "P6\n"
test imgPhoto-17.4 {photo write: default format not supported} -setup {
    image create photo photo1 -data {{blue blue} {red red} {green green}}
    set f [makeFile {} test.txt]
} -body {
    photo1 write $f -format default
} -cleanup {
    imageCleanup
    catch {removeFile $f}
    unset f
} -returnCodes error -result \
    {image file format "default" has no file writing capability}
test imgPhoto-17.5 {photo write: file with extension .default} -setup {
    image create photo photo1 -data {{black}}
    set f [makeFile {} test.default]
} -body {
    photo1 write $f
} -cleanup {
    imageCleanup
    catch {removeFile $f}
    unset f
} -returnCodes error -result \
    {image file format "default" has no file writing capability}

test imgPhoto-18.1 {MatchFileFormat: "default" format not supported} -setup {
    image create photo photo1
    set f [makeFile {} test.txt]
} -body {
    photo1 read $f -format default
} -cleanup {
    imageCleanup
    catch {removeFile $f}
    unset f
} -returnCodes error -result {-file option isn't supported for default images}

test imgPhoto-19.1 {MatchStringFormat: with "-format default"} -setup {
    image create photo photo1
} -body {
    photo1 put {{red blue red} {yellow green yellow}} -format default
    list [image width photo1] [image height photo1]
} -cleanup {
    imageCleanup
} -result {3 2}
test imgPhoto-19.2 {MatchStringFormat: without -format option,
        default fmt} -body {
    image create photo photo1
    photo1 put {{red} {green}}
    list [image width photo1] [image height photo1]
} -cleanup {
    imageCleanup
} -result {1 2}
test imgPhoto-19.3 {MatchStringFormat: "-format ppm"} -setup {
    image create photo photo1
    image create photo photo2
    photo2 put {cyan cyan}
    set imgData [photo2 data -format ppm]
} -body {
    photo1 put $imgData -format ppm
    list [image width photo1] [image height photo1]
} -cleanup {
    unset imgData
    imageCleanup
} -result {1 2}
test imgPhoto-19.4 {MatchStringFormat: ppm fmt, without opt} -setup {
    image create photo photo1 -file $teapotPhotoFile
    image create photo photo2
} -body {
    set imgData [photo1 data -format ppm]
    photo2 put $imgData
    list [image width photo2] [image height photo2]
} -cleanup {
    imageCleanup
    unset imgData
} -result {256 256}
test imgPhoto-19.5 {MatchStirngFormat: unknown -format} -setup {
    image create photo photo1
} -body {
    photo1 put {} -format bogus
} -cleanup {
    imageCleanup
} -returnCodes error -result {image format "bogus" is not supported}
test imgPhoto-19.6 {MatchStringFormat: invalid data for default} -setup {
    image create photo photo1
} -body {
    photo1 put bogus
} -cleanup {
    imageCleanup
} -returnCodes error -result {invalid color name "bogus"}
test imgPhoto-19.7 {MatchStringFormat: invalid data for default} -setup {
    image create photo photo1
} -body {
    photo1 put bogus -format dEFault
} -cleanup {
    imageCleanup
} -returnCodes error -result {invalid color name "bogus"}
test imgPhoto-19.8 {MatchStirngFormat: invalid data for gif} -setup {
    image create photo photo1
} -body {
    photo1 put bogus -format giF
} -cleanup {
    imageCleanup
} -returnCodes error -result {couldn't recognize image data}

# Reject corrupted or truncated image [Bug b601ce3ab1].
# WARNING - tests 20.1-20.9 will cause a segfault on 8.5.19 and lower,
#           and on 8.6.6 and lower.
test imgPhoto-20.1 {Reject corrupted GIF (binary string)} -setup {
    set data [binary decode base64 {
	R0lGODlhAAQABP8zM/8z/zP/MzP/////M////yH5CiwheLrcLTBCd6Tv2qW16tdK4jhV
	5qpraXIvM1JlNyAgOw==
    }]
} -body {
    image create photo gif1 -data $data
} -cleanup {
    catch {image delete gif1}
} -returnCodes error -result {error reading color map|not enough free memory for image buffer} -match regexp
test imgPhoto-20.2 {Reject corrupted GIF (base 64 string)} -setup {
    set data {
	R0lGODlhAAQABP8zM/8z/zP/MzP/////M////yH5CiwheLrcLTBCd6Tv2qW16tdK4jhV
	5qpraXIvM1JlNyAgOw==
    }
} -body {
    image create photo gif1 -data $data
} -cleanup {
    catch {image delete gif1}
} -returnCodes error -result {error reading color map|not enough free memory for image buffer} -match regexp
test imgPhoto-20.3 {Reject corrupted GIF (file)} -setup {
    set fileName [file join [file dirname [info script]] corruptMangled.gif]
} -body {
    image create photo gif1 -file $fileName
} -cleanup {
    catch {image delete gif1}
} -returnCodes error -result {error reading color map|not enough free memory for image buffer} -match regexp
test imgPhoto-20.4 {Reject truncated GIF (binary string)} -setup {
    set data [binary decode base64 {
	R0lGODlhEAAQAMIHAAAAADMz//8zM/8z/zP/MzP///8=
    }]
} -body {
    image create photo gif1 -data $data
} -cleanup {
    catch {image delete gif1}
} -returnCodes error -result {error reading color map}
test imgPhoto-20.5 {Reject truncated GIF (base 64 string)} -setup {
    set data {
	R0lGODlhEAAQAMIHAAAAADMz//8zM/8z/zP/MzP///8=
    }
} -body {
    image create photo gif1 -data $data
} -cleanup {
    catch {image delete gif1}
} -returnCodes error -result {error reading color map}
test imgPhoto-20.6 {Reject truncated GIF (file)} -setup {
    set fileName [file join [file dirname [info script]] corruptTruncated.gif]
} -body {
    image create photo gif1 -file $fileName
} -cleanup {
    catch {image delete gif1}
} -returnCodes error -result {error reading color map}
test imgPhoto-20.6.1 {Reject truncated GIF in Colormap - ticket 865af0148c - file} -setup {
    set fileName [file join [file dirname [info script]] corruptTruncatedColormap.gif]
} -body {
    image create photo gif1 -file $fileName
} -cleanup {
    catch {image delete gif1}
} -returnCodes error -result {GIF file truncated}
test imgPhoto-20.6.2 {Reject truncated GIF in Colormap - ticket 865af0148c - data} -setup {
    set fileName [file join [file dirname [info script]] corruptTruncatedColormap.gif]
    set h [open $fileName rb]
    set d [read $h]
    close $h
} -body {
    image create photo gif1 -data $d
} -cleanup {
    catch {image delete gif1}
} -returnCodes error -result {GIF file truncated}
test imgPhoto-20.7 {Reject corrupted GIF (> 4Gb) (binary string)} -constraints {
    nonPortable
} -setup {
    # About the non portability constraint of this test: see ticket [cc42cc18a5]
    # If there is insufficient memory, the error message
    # {not enough free memory for image buffer} should be returned.
    # Instead, some systems (e.g. FreeBSD 11.1) terminate the test interpreter.
    set data [binary decode base64 {
	R0lGODlhwmYz//8zM/8z/zP/MzP/////M////yH5Ciwhe
	LrcLTBCd6Tv2qW16tdK4jhV5qpraXIvM1JlNyAgOw==
    }]
} -body {
    image create photo gif1 -data $data
} -cleanup {
    catch {image delete gif1}
} -returnCodes error -result {error reading color map|not enough free memory for image buffer} -match regexp
test imgPhoto-20.8 {Reject corrupted GIF (> 4Gb) (base 64 string)} -constraints {
    nonPortable
} -setup {
    # About the non portability constraint of this test: see ticket [cc42cc18a5]
    # If there is insufficient memory, the error message
    # {not enough free memory for image buffer} should be returned.
    # Instead, some systems (e.g. FreeBSD 11.1) terminate the test interpreter.
    set data {
	R0lGODlhwmYz//8zM/8z/zP/MzP/////M////yH5Ciwhe
	LrcLTBCd6Tv2qW16tdK4jhV5qpraXIvM1JlNyAgOw==
    }
} -body {
    image create photo gif1 -data $data
} -cleanup {
    catch {image delete gif1}
} -returnCodes error -result {error reading color map|not enough free memory for image buffer} -match regexp
test imgPhoto-20.9 {Reject corrupted GIF (> 4Gb) (file)} -constraints {
    nonPortable
} -setup {
    # About the non portability constraint of this test: see ticket [cc42cc18a5]
    # If there is insufficient memory, the error message
    # {not enough free memory for image buffer} should be returned.
    # Instead, some systems (e.g. FreeBSD 11.1) terminate the test interpreter.
    set fileName [file join [file dirname [info script]] corruptMangled4G.gif]
} -body {
    image create photo gif1 -file $fileName
} -cleanup {
    catch {image delete gif1}
} -returnCodes error -result {error reading color map|not enough free memory for image buffer} -match regexp
test imgPhoto-20.10 {Valid GIF (binary string)} -setup {
    # Test the binary string reader with a valid GIF.
    # This is not tested elsewhere.
    # Tests 20.11, 20.12, with matching data, are included for completeness.
    set data [binary decode base64 {
	R0lGODlhEAAQAMIHAAAAADMz//8zM/8z/zP/MzP/////M////yH5BAEKAAcALAAA
	AAAQABAAAAMheLrcLTBCd6QV79qlterXB0riOFXmmapraXIvM1IdZTcJADs=
    }]
} -body {
    image create photo gif1 -data $data
} -cleanup {
    catch {image delete gif1}
} -result gif1
test imgPhoto-20.11 {Valid GIF (base 64 string)} -setup {
    set data {
	R0lGODlhEAAQAMIHAAAAADMz//8zM/8z/zP/MzP/////M////yH5BAEKAAcALAAA
	AAAQABAAAAMheLrcLTBCd6QV79qlterXB0riOFXmmapraXIvM1IdZTcJADs=
    }
} -body {
    image create photo gif1 -data $data
} -cleanup {
    catch {image delete gif1}
} -result gif1
test imgPhoto-20.12 {Valid GIF (file)} -setup {
    set fileName [file join [file dirname [info script]] red.gif]
} -body {
    image create photo gif1 -file $fileName
} -cleanup {
    catch {image delete gif1}
} -result gif1

# imgPhoto-21.x : Tk_PhotoGetMetadata

test imgPhoto-21.1 {option -metadata, get configure list} -setup {
    image create photo photo1 -metadata {dpi 100}
} -body {
    photo1 configure -metadata
} -cleanup {
    catch {image delete photo1}
} -result {-metadata {} {} {} {dpi 100}}

test imgPhoto-21.2 {option -metadata, get value} -setup {
    image create photo photo1 -metadata {dpi 100}
} -body {
    photo1 cget -metadata
} -cleanup {
    catch {image delete photo1}
} -result {dpi 100}

test imgPhoto-21.3 {option -metadata, get default value} -setup {
    image create photo photo1
} -body {
    photo1 cget -metadata
} -cleanup {
    catch {image delete photo1}
} -result {}

test imgPhoto-21.4 {bug daa10097: only 3 metadata list items on configure} -setup {
    image create photo photo1
} -body {
    set a {}
    foreach line [photo1 configure] {
        if {[lindex $line 0] eq {-metadata}} {
            set a $line
        }
    }
    set a
} -cleanup {
    catch {image delete photo1}
} -result {-metadata {} {} {} {}}


# imgPhoto-22.x : Tk_PhotoSetMetadata

test imgPhoto-22.1 {option -metadata, set value} -setup {
    image create photo photo1
} -body {
    photo1 configure -metadata {dpi 100}
    photo1 cget -metadata
} -cleanup {
    catch {image delete photo1}
} -result {dpi 100}

test imgPhoto-22.2 {option -metadata, change value} -setup {
    image create photo photo1 -metadata {dpi 200}
} -body {
    photo1 configure -metadata {dpi 100}
    photo1 cget -metadata
} -cleanup {
    catch {image delete photo1}
} -result {dpi 100}

test imgPhoto-22.3 {option -metadata, clear value} -setup {
    image create photo photo1 -metadata {dpi 200}
} -body {
    photo1 configure -metadata {}
    photo1 cget -metadata
} -cleanup {
    catch {image delete photo1}
} -result {}

# 23.x GIF images with metadata

# The following gif core data is used by the following data.
# N.B. this is the same image as test imgPhoto-18.10

# size 16x16, global color table size: 8
set gifstart "GIF89a\x10\x00\x10\x00\xc2\x07\x00"
# color table
append gifstart "\x00\x00\x00\x33\x33\xff\xff\x33\x33\xff\x33\xff\x33\xff\x33\x33\xff\xff\xff\xff\x33\xff\xff\xff"
# Graphic control extension: Transparent color index: 7 (not needed here)
# append gifdata "\x21\xf9\x04\x01\x0a\x00\x07\x00"
# Image descriptor: 16x16, no local color table
set gifdata "\x2c\x00\x00\x00\x00\x10\x00\x10\x00\x00"
# Image data
append gifdata "\x03\x21\x78\xba\xdc\x2d\x30\x42\x77\xa4\x15\xef\xda\xa5\xb5\xea\xd7\x07\x4a\xe2\x38\x55\xe6\x99\xaa\x6b\x69\x72\x2f\x33\x52\x1d\x65\x37\x09\x00"
set gifend "\x3b"

test imgPhoto-23.1 {GIF comment before image data (-data)} -setup {
    set data $::gifstart
    # Append a comment extension block with data "ABCD"
    append data "\x21\xfe\x04" "ABCD" "\x0"
    # Trailer
    append data $::gifdata $::gifend
} -body {
    image create photo gif1 -data $data
    gif1 cget -metadata
} -cleanup {
    catch {image delete gif1}
} -result {comment ABCD}

test imgPhoto-23.2 {GIF file comment before image data (-file)} -setup {
    set data $::gifstart
    # Append a comment extension block with data "ABCD"
    append data "\x21\xfe\x04" "ABCD" "\x0"
    # Trailer
    append data $::gifdata $::gifend
    set path [file join [configure -tmpdir] test.gif]
    set h [open $path "WRONLY BINARY CREAT"]
    puts -nonewline $h $data
    close $h
} -body {
    image create photo gif1 -file $path
    gif1 cget -metadata
} -cleanup {
    catch {image delete gif1}
    file delete $path
} -result {comment ABCD}

test imgPhoto-23.3 {GIF comment after image data (-data)} -setup {
    set data $::gifstart
    append data $::gifdata
    # Append a comment extension block with data "ABCD"
    append data "\x21\xfe\x04" "ABCD" "\x0"
    # Trailer
    append data $::gifend
} -body {
    image create photo gif1 -data $data
    gif1 cget -metadata
} -cleanup {
    catch {image delete gif1}
} -result {comment ABCD}

test imgPhoto-23.4 {GIF comment after image data (-file)} -setup {
    set data $::gifstart
    append data $::gifdata
    # Append a comment extension block with data "ABCD"
    append data "\x21\xfe\x04" "ABCD" "\x0"
    # Trailer
    append data $::gifend
    set path [file join [configure -tmpdir] test.gif]
    set h [open $path "WRONLY BINARY CREAT"]
    puts $h $data
    close $h
} -body {
    image create photo gif1 -file $path
    gif1 cget -metadata
} -cleanup {
    catch {image delete gif1}
    file delete $path
} -result {comment ABCD}

test imgPhoto-23.5 {Two GIF comment blocks (-data)} -setup {
    set data $::gifstart
    # Append a comment extension block with data "1234"
    append data "\x21\xfe\x04" "1234" "\x0"
    append data $::gifdata
    # Append a comment extension block with data "ABCD"
    append data "\x21\xfe\x04" "ABCD" "\x0"
    # Trailer
    append data $::gifend
} -body {
    image create photo gif1 -data $data
    gif1 cget -metadata
} -cleanup {
    catch {image delete gif1}
} -result {comment ABCD}

test imgPhoto-23.6 {Two GIF comment blocks (-file)} -setup {
    set data $::gifstart
    # Append a comment extension block with data "1234"
    append data "\x21\xfe\x04" "1234" "\x0"
    append data $::gifdata
    # Append a comment extension block with data "ABCD"
    append data "\x21\xfe\x04" "ABCD" "\x0"
    # Trailer
    append data $::gifend
    set path [file join [configure -tmpdir] test.gif]
    set h [open $path "WRONLY BINARY CREAT"]
    puts $h $data
    close $h
} -body {
    image create photo gif1 -file $path
    gif1 cget -metadata
} -cleanup {
    catch {image delete gif1}
    file delete $path
} -result {comment ABCD}

test imgPhoto-23.7 {create: test if shared metadata object is not preserved\
	(-data)}\
-setup {
    set data $::gifstart
    # Append a comment extension block with data "ABCD"
    append data "\x21\xfe\x04" "ABCD" "\x0"
    # Trailer
    append data $::gifdata $::gifend
} -body {
    set metadataDict [dict create A 1]
    set metadataDict2 $metadataDict
    image create photo gif1 -data $data -metadata $metadataDict
    list [dict get [gif1 cget -metadata]] $metadataDict $metadataDict2
} -cleanup {
    catch {image delete gif1}
} -result {{A 1 comment ABCD} {A 1} {A 1}}

test imgPhoto-23.8 {create: test if shared metadata object is not preserved\
	(-file)}\
-setup {
    set data $::gifstart
    # Append a comment extension block with data "ABCD"
    append data "\x21\xfe\x04" "ABCD" "\x0"
    # Trailer
    append data $::gifdata $::gifend

    set path [file join [configure -tmpdir] test.gif]
    set h [open $path "WRONLY BINARY CREAT"]
    puts $h $data
    close $h
} -body {
    set metadataDict [dict create A 1]
    set metadataDict2 $metadataDict
    image create photo gif1 -file $path -metadata $metadataDict
    list [dict get [gif1 cget -metadata]] $metadataDict $metadataDict2
} -cleanup {
    catch {image delete gif1}
    file delete $path
} -result {{A 1 comment ABCD} {A 1} {A 1}}

test imgPhoto-23.9 {configure: test if shared metadata object is not\
	preserved (empty image, -data)}\
-setup {
    set data $::gifstart
    # Append a comment extension block with data "ABCD"
    append data "\x21\xfe\x04" "ABCD" "\x0"
    # Trailer
    append data $::gifdata $::gifend
} -body {
    image create photo gif1
    set metadataDict [dict create A 1]
    set metadataDict2 $metadataDict
    gif1 configure -data $data -format gif -metadata $metadataDict
    list [dict get [gif1 cget -metadata]] $metadataDict $metadataDict2
} -cleanup {
    catch {image delete gif1}
} -result {{A 1 comment ABCD} {A 1} {A 1}}

test imgPhoto-23.10 {configure: test if shared metadata object is not preserved\
	(empty image, -file)}\
-setup {
    set data $::gifstart
    # Append a comment extension block with data "ABCD"
    append data "\x21\xfe\x04" "ABCD" "\x0"
    # Trailer
    append data $::gifdata $::gifend

    set path [file join [configure -tmpdir] test.gif]
    set h [open $path "WRONLY BINARY CREAT"]
    puts $h $data
    close $h
} -body {
    image create photo gif1
    set metadataDict [dict create A 1]
    set metadataDict2 $metadataDict
    gif1 configure -file $path -format gif -metadata $metadataDict
    list [dict get [gif1 cget -metadata]] $metadataDict $metadataDict2
} -cleanup {
    catch {image delete gif1}
    file delete $path
} -result {{A 1 comment ABCD} {A 1} {A 1}}

test imgPhoto-23.11 {configure: test if shared metadata object is not preserved\
	(metadata replace, -data}\
-setup {
    set data $::gifstart
    # Append a comment extension block with data "ABCD"
    append data "\x21\xfe\x04" "ABCD" "\x0"
    # Trailer
    append data $::gifdata $::gifend
} -body {
    image create photo gif1 -data "$::gifstart$::gifdata$::gifend"
    set metadataDict [dict create A 1]
    set metadataDict2 $metadataDict
    gif1 configure -data $data -format gif -metadata $metadataDict
    list [dict get [gif1 cget -metadata]] $metadataDict $metadataDict2
} -cleanup {
    catch {image delete gif1}
} -result {{A 1 comment ABCD} {A 1} {A 1}}

test imgPhoto-23.12 {configure: test if shared metadata object is not preserved\
	(metadata replace, -file}\
-setup {
    set data $::gifstart
    # Append a comment extension block with data "ABCD"
    append data "\x21\xfe\x04" "ABCD" "\x0"
    # Trailer
    append data $::gifdata $::gifend

    set path [file join [configure -tmpdir] test.gif]
    set h [open $path "WRONLY BINARY CREAT"]
    puts $h $data
    close $h
} -body {
    image create photo gif1 -data "$::gifstart$::gifdata$::gifend"
    set metadataDict [dict create A 1]
    set metadataDict2 $metadataDict
    gif1 configure -file $path -format gif -metadata $metadataDict
    list [dict get [gif1 cget -metadata]] $metadataDict $metadataDict2
} -cleanup {
    catch {image delete gif1}
    file delete $path
} -result {{A 1 comment ABCD} {A 1} {A 1}}

test imgPhoto-23.13 {configure: test if shared metadata object is not preserved\
	(-data)}\
-setup {
    set data $::gifstart$::gifdata$::gifend
} -body {
    image create photo gif1 -data $data
    set metadataDict [dict create A 1]
    set metadataDict2 $metadataDict
    set data $::gifstart
    # Append a comment extension block with data "ABCD"
    append data "\x21\xfe\x04" "ABCD" "\x0"
    # Trailer
    append data $::gifdata $::gifend
    gif1 configure -data $data -format gif -metadata $metadataDict
    list [dict get [gif1 cget -metadata]] $metadataDict $metadataDict2
} -cleanup {
    catch {image delete gif1}
} -result {{A 1 comment ABCD} {A 1} {A 1}}

test imgPhoto-23.14 {configure: test if shared metadata object is not preserved\
	(-file)}\
-setup {
    set data $::gifstart
    # Append a comment extension block with data "ABCD"
    append data "\x21\xfe\x04" "ABCD" "\x0"
    # Trailer
    append data $::gifdata $::gifend

    set path [file join [configure -tmpdir] test.gif]
    set h [open $path "WRONLY BINARY CREAT"]
    puts $h $data
    close $h
} -body {
    image create photo gif1 -data "$::gifstart$::gifdata$::gifend"
    set metadataDict [dict create A 1]
    set metadataDict2 $metadataDict
    gif1 configure -file $path -format gif -metadata $metadataDict
    list [dict get [gif1 cget -metadata]] $metadataDict $metadataDict2
} -cleanup {
    catch {image delete gif1}
    file delete $path
} -result {{A 1 comment ABCD} {A 1} {A 1}}

test imgPhoto-23.15 {output data with comment (from -metadata argument)}\
-setup {
    set data $::gifstart$::gifdata$::gifend
} -body {
    image create photo gif1 -data $data
    set gifData [gif1 data -format gif -metadata [dict create comment ABCD]]
} -cleanup {
    catch {image delete gif1}
} -match glob -result {*ABCD*}

test imgPhoto-23.16 {output data with comment (from -metadata property)}\
-setup {
    set data $::gifstart$::gifdata$::gifend
} -body {
    image create photo gif1 -data $data
    gif1 configure -metadata [dict create comment ABCD]
    set gifData [gif1 data -format gif]
} -cleanup {
    catch {image delete gif1}
} -match glob -result {*ABCD*}

test imgPhoto-23.17 {output file with comment (from -metadata property)}\
-setup {
    set data $::gifstart$::gifdata$::gifend
    set path [file join [configure -tmpdir] test.gif]
} -body {
    image create photo gif1 -data $data
    gif1 configure -metadata [dict create comment ABCD]
    gif1 write $path -format gif
    image delete gif1
    image create photo gif1 -file $path
    dict get [gif1 cget -metadata] comment
} -cleanup {
    catch {image delete gif1}
    file delete $path
} -result {ABCD}

test imgPhoto-23.18 {configure: empty metadata parameter overwrites image metadata} -setup {
    image create photo gif1 -data $::gifstart$::gifdata$::gifend\
	    -metadata {foo bar}
    set data $::gifstart
    # Append a comment extension block with data "ABCD"
    append data "\x21\xfe\x04" "ABCD" "\x0"
    # Trailer
    append data $::gifdata $::gifend
} -body {
    gif1 configure -data $data -metadata {}
    gif1 cget -metadata
} -cleanup {
    catch {image delete gif1}
} -result {comment ABCD}

test imgPhoto-23.19 {write: empty metadata parameter overwrites image metadata} -setup {
    image create photo gif1 -data $::gifstart$::gifdata$::gifend\
	    -metadata {comment bar}
    set path [file join [configure -tmpdir] test.gif]
} -body {
    gif1 write $path -format gif -metadata {}
    image delete gif1
    image create photo gif1 -file $path
    dict size [gif1 cget -metadata]
} -cleanup {
    catch {image delete gif1}
    file delete $path
} -result {0}

test imgPhoto-23.20 {data: empty metadata parameter overwrites image metadata} -setup {
    image create photo gif1 -data $::gifstart$::gifdata$::gifend\
	    -metadata {comment bar}
} -body {
    set data [gif1 data -format gif -metadata {}]
    image delete gif1
    image create photo gif1 -data $data
    dict size [gif1 cget -metadata]
} -cleanup {
    catch {image delete gif1}
    file delete $path
} -result {0}

test imgPhoto-23.21 {GIF delay time metadata} -setup {
    set data $::gifstart
    # Graphic control extension: 10 1/100s delay time
    append data "\x21\xf9\x04\x00\x0a\x00\x00\x00"
    # Trailer
    append data $::gifdata $::gifend
} -body {
    image create photo gif1 -data $data
    gif1 cget -metadata
} -cleanup {
    catch {image delete gif1}
} -result {{delay time} 10}

test imgPhoto-23.22 {GIF disposal method "do not dispose" metadata} -setup {
    set data $::gifstart
    # Graphic control extension: disposdal method:
    append data "\x21\xf9\x04\x04\x00\x00\x00\x00"
    # Trailer
    append data $::gifdata $::gifend
} -body {
    image create photo gif1 -data $data
    gif1 cget -metadata
} -cleanup {
    catch {image delete gif1}
} -result {{disposal method} {do not dispose}}

test imgPhoto-23.23 {GIF disposal method "restore to background color" metadata} -setup {
    set data $::gifstart
    # Graphic control extension: disposdal method:
    append data "\x21\xf9\x04\x08\x00\x00\x00\x00"
    # Trailer
    append data $::gifdata $::gifend
} -body {
    image create photo gif1 -data $data
    gif1 cget -metadata
} -cleanup {
    catch {image delete gif1}
} -result {{disposal method} {restore to background color}}

test imgPhoto-23.24 {GIF disposal method "restore to previous" metadata} -setup {
    set data $::gifstart
    # Graphic control extension: disposdal method:
    append data "\x21\xf9\x04\x0C\x00\x00\x00\x00"
    # Trailer
    append data $::gifdata $::gifend
} -body {
    image create photo gif1 -data $data
    gif1 cget -metadata
} -cleanup {
    catch {image delete gif1}
} -result {{disposal method} {restore to previous}}

test imgPhoto-23.25 {GIF user input flag metadata} -setup {
    set data $::gifstart
    # Graphic control extension: disposdal method:
    append data "\x21\xf9\x04\x02\x00\x00\x00\x00"
    # Trailer
    append data $::gifdata $::gifend
} -body {
    image create photo gif1 -data $data
    gif1 cget -metadata
} -cleanup {
    catch {image delete gif1}
} -result {{user interaction} 1}

test imgPhoto-23.26 {GIF update region metadata} -setup {
    # size 32x32, global color table size: 8
    set data "GIF89a\x20\x00\x20\x00\xc2\x07\x00"
    # color table
    append data "\x00\x00\x00\x33\x33\xff\xff\x33\x33\xff\x33\xff\x33\xff\x33\x33\xff\xff\xff\xff\x33\xff\xff\xff"
    # Trailer
    # As this is 16x16, we will get an update region setting
    append data $::gifdata $::gifend
} -body {
    image create photo gif1 -data $data
    gif1 cget -metadata
} -cleanup {
    catch {image delete gif1}
} -result {{update region} {0 0 16 16}}

test imgPhoto-23.27 {GIF multiple options metadata} -setup {
    # size 32x32, global color table size: 8
    set data "GIF89a\x20\x00\x20\x00\xc2\x07\x00"
    # color table
    append data "\x00\x00\x00\x33\x33\xff\xff\x33\x33\xff\x33\xff\x33\xff\x33\x33\xff\xff\xff\xff\x33\xff\xff\xff"
    # Graphic control extension: do not dispose, user interaction, transparent color, delay time 10
    append data "\x21\xf9\x04\x07\x0a\x00\x01\x00"
    # Image data and trailer
    # As this is 16x16, we will get an update region setting
    append data $::gifdata $::gifend
} -body {
    image create photo gif1 -data $data
    gif1 cget -metadata
} -cleanup {
    catch {image delete gif1}
} -result {{update region} {0 0 16 16} {delay time} 10 {disposal method} {do not dispose} {user interaction} 1}

test imgPhoto-23.28 {GIF multiple options metadata in -index 0} -setup {
    # size 32x32, global color table size: 8
    set data "GIF89a\x20\x00\x20\x00\xc2\x07\x00"
    # color table
    append data "\x00\x00\x00\x33\x33\xff\xff\x33\x33\xff\x33\xff\x33\xff\x33\x33\xff\xff\xff\xff\x33\xff\xff\xff"
    # Graphic control extension: do not dispose, user interaction, transparent color, delay time 4096
    append data "\x21\xf9\x04\x07\x00\x10\x01\x00"
    # Image data
    # As this is 16x16, we will get an update region setting
    append data $::gifdata
    # Graphic control extension: restore to background, delay time 1
    append data "\x21\xf9\x04\x08\x01\x00\x02\x00"
    # Image data and trailer
    # As this is 16x16, we will get an update region setting
    append data $::gifdata $::gifend
} -body {
    image create photo gif1 -data $data -format "gif -index 0"
    gif1 cget -metadata
} -cleanup {
    catch {image delete gif1}
} -result {{update region} {0 0 16 16} {delay time} 4096 {disposal method} {do not dispose} {user interaction} 1}

test imgPhoto-23.29 {GIF multiple options metadata in -index 1} -setup {
    # size 32x32, global color table size: 8
    set data "GIF89a\x20\x00\x20\x00\xc2\x07\x00"
    # color table
    append data "\x00\x00\x00\x33\x33\xff\xff\x33\x33\xff\x33\xff\x33\xff\x33\x33\xff\xff\xff\xff\x33\xff\xff\xff"
    # Graphic control extension: restore to background, delay time 1
    append data "\x21\xf9\x04\x08\x01\x00\x02\x00"
    # Image data
    # As this is 16x16, we will get an update region setting
    append data $::gifdata
    # Graphic control extension: do not dispose, user interaction, transparent color, delay time 4096
    append data "\x21\xf9\x04\x07\x00\x10\x01\x00"
    # Image data and trailer
    # As this is 16x16, we will get an update region setting
    append data $::gifdata $::gifend
} -body {
    image create photo gif1 -data $data -format "gif -index 1"
    gif1 cget -metadata
} -cleanup {
    catch {image delete gif1}
} -result {{update region} {0 0 16 16} {delay time} 4096 {disposal method} {do not dispose} {user interaction} 1}

unset -nocomplain gifstart gifdata gifend


set earthPhotoFile [file join [file dirname [info script]] earth.gif]
test imgPhoto-24.1 {Read GIF file with -from option - Bug [1576528]} -body {
    set earthPhotoFile [file join [file dirname [info script]] earth.gif]
    image create photo gif1
    gif1 read $earthPhotoFile -from 152 62 185 97
    list [lindex [lindex [gif1 data] 0] 0] [image width gif1] [image height gif1]
} -cleanup {
    catch {image delete gif1}
} -result {{#d8c8b8} 33 35}
test imgPhoto-24.2 {Read GIF file, copy with -from option} -body {
    set earthPhotoFile [file join [file dirname [info script]] earth.gif]
    image create photo gif1 -file $earthPhotoFile
    image create photo gif2
    gif2 copy gif1 -from 152 62 185 97
    list [lindex [lindex [gif2 data] 0] 0] [image width gif2] [image height gif2]
} -cleanup {
    catch {image delete gif1 ; image delete gif2}
} -result {{#d8c8b8} 33 35}
test imgPhoto-24.3 {Read GIF file with -to option} -body {
    image create photo gif1
    gif1 read $earthPhotoFile -to 100 200
    list [lindex [lindex [gif1 data] 262] 252] [image width gif1] [image height gif1]
} -cleanup {
    catch {image delete gif1}
} -result {{#d8c8b8} 420 400}
test imgPhoto-24.4 {Read GIF file with -from and -to options} -body {
    set earthPhotoFile [file join [file dirname [info script]] earth.gif]
    image create photo gif1
    gif1 read $earthPhotoFile -from 152 62 185 97 -to 100 200
    list [lindex [lindex [gif1 data] 200] 100] [image width gif1] [image height gif1]
} -cleanup {
    catch {image delete gif1}
} -result {{#d8c8b8} 133 235}
test imgPhoto-24.5 {Read GIF file with -from, -to and -shrink options} -body {
    set earthPhotoFile [file join [file dirname [info script]] earth.gif]
    image create photo gif1 -file $teapotPhotoFile
    gif1 read $earthPhotoFile -from 152 62 185 97 -to 80 120 -shrink
    list [lindex [lindex [gif1 data] 120] 80] [image width gif1] [image height gif1]
} -cleanup {
    catch {image delete gif1}
} -result {{#d8c8b8} 113 155}
test imgPhoto-24.6 {Read GIF file with -from option, read large region from small file} -body {
    set earthPhotoFile [file join [file dirname [info script]] earth.gif]
    image create photo gif1
    catch {gif1 read $earthPhotoFile -from 152 62 2000 1000} msg
    list $msg [image width gif1] [image height gif1]
} -cleanup {
    catch {image delete gif1}
} -result {{coordinates for -from option extend outside source image} 0 0}
unset earthPhotoFile

set ousterPhotoFile [file join [file dirname [info script]] ouster.png]
test imgPhoto-25.1 {Read PNG file with -from option - Bug [1576528]} -body {
    image create photo png1
    png1 read $ousterPhotoFile -from 102 62 135 97
    list [lindex [lindex [png1 data] 0] 0] [image width png1] [image height png1]
} -cleanup {
    catch {image delete png1}
} -result {{#c97962} 33 35}
test imgPhoto-25.2 {Read PNG file, copy with -from option} -body {
    image create photo png1 -file $ousterPhotoFile
    image create photo png2
    png2 copy png1 -from 102 62 135 97
    list [lindex [lindex [png2 data] 0] 0] [image width png2] [image height png2]
} -cleanup {
    catch {image delete png1 ; image delete png2}
} -result {{#c97962} 33 35}
test imgPhoto-25.3 {Read PNG file with -to option} -body {
    image create photo png1
    png1 read $ousterPhotoFile -to 100 200
    list [lindex [lindex [png1 data] 262] 202] [image width png1] [image height png1]
} -cleanup {
    catch {image delete png1}
} -result {{#c97962} 242 381}
test imgPhoto-25.4 {Read PNG file with -from and -to options} -body {
    image create photo png1
    png1 read $ousterPhotoFile -from 102 62 135 97 -to 100 200
    list [lindex [lindex [png1 data] 200] 100] [image width png1] [image height png1]
} -cleanup {
    catch {image delete png1}
} -result {{#c97962} 133 235}
test imgPhoto-25.5 {Read PNG file with -from, -to and -shrink options} -body {
    image create photo png1 -file $teapotPhotoFile
    png1 read $ousterPhotoFile -from 102 62 135 97 -to 80 120 -shrink
    list [lindex [lindex [png1 data] 120] 80] [image width png1] [image height png1]
} -cleanup {
    catch {image delete png1}
} -result {{#c97962} 113 155}
test imgPhoto-25.6 {Read PNG file with -from option, read large region from small file} -body {
    image create photo png1
    catch {png1 read $ousterPhotoFile -from 102 62 2000 1000} msg
    list $msg [image width png1] [image height png1]
} -cleanup {
    catch {image delete png1}
} -result {{coordinates for -from option extend outside source image} 0 0}
unset ousterPhotoFile

catch {rename foreachPixel {}}
catch {rename checkImgTrans {}}
catch {rename checkImgTransLoop {}}
imageFinish

# cleanup
removeFile README-imgPhoto
cleanupTests
return

# Local variables:
# mode: tcl
# End:
