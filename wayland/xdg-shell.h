/*
Copyright © 2008-2012 Kristian Høgsberg
Copyright © 2010-2012 Intel Corporation
Copyright © 2011 Benjamin Franzke
Copyright © 2012 Collabora, Ltd.

Permission is hereby granted, free of charge, to any person obtaining a
copy of this software and associated documentation files (the "Software"),
to deal in the Software without restriction, including without limitation
the rights to use, copy, modify, merge, publish, distribute, sublicense,
and/or sell copies of the Software, and to permit persons to whom the
Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice (including the next
paragraph) shall be included in all copies or substantial portions of the
Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
*/

/* Generated by wayland-scanner 1.22.0 */

#ifndef XDG_SHELL_CLIENT_PROTOCOL_H
#define XDG_SHELL_CLIENT_PROTOCOL_H

#include <stdint.h>
#include <stddef.h>
#include "wayland-client.h"

#ifdef  __cplusplus
extern "C" {
#endif

/**
 * @page page_xdg_shell The xdg_shell protocol
 * @section page_ifaces_xdg_shell Interfaces
 * - @subpage page_iface_xdg_wm_base - create desktop-style surfaces
 * - @subpage page_iface_xdg_positioner - child surface positioner
 * - @subpage page_iface_xdg_surface - desktop user interface surface base interface
 * - @subpage page_iface_xdg_toplevel - toplevel surface
 * - @subpage page_iface_xdg_popup - short-lived, popup surfaces for menus
 * @section page_copyright_xdg_shell Copyright
 * <pre>
 *
 * Copyright © 2008-2013 Kristian Høgsberg
 * Copyright © 2013      Rafael Antognolli
 * Copyright © 2013      Jasper St. Pierre
 * Copyright © 2010-2013 Intel Corporation
 * Copyright © 2015-2017 Samsung Electronics Co., Ltd
 * Copyright © 2015-2017 Red Hat Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 * </pre>
 */
struct wl_surface;
struct xdg_popup;
struct xdg_positioner;
struct xdg_surface;
struct xdg_toplevel;
struct xdg_wm_base;

#ifndef XDG_WM_BASE_INTERFACE
#define XDG_WM_BASE_INTERFACE
/**
 * @page page_iface_xdg_wm_base xdg_wm_base
 * @section page_iface_xdg_wm_base_desc Description
 *
 * The xdg_wm_base interface is exposed as a global object enabling clients
 * to turn their wl_surfaces into windows in a desktop environment. It
 * defines the basic functionality needed for clients and the compositor to
 * create windows that can be dragged, resized, maximized, etc.
 * @section page_iface_xdg_wm_base_api API
 * See @ref iface_xdg_wm_base.
 */
/**
 * @defgroup iface_xdg_wm_base The xdg_wm_base interface
 *
 * The xdg_wm_base interface is exposed as a global object enabling clients
 * to turn their wl_surfaces into windows in a desktop environment. It
 * defines the basic functionality needed for clients and the compositor to
 * create windows that can be dragged, resized, maximized, etc.
 */
extern const struct wl_interface xdg_wm_base_interface;
#endif
#ifndef XDG_POSITIONER_INTERFACE
#define XDG_POSITIONER_INTERFACE
/**
 * @page page_iface_xdg_positioner xdg_positioner
 * @section page_iface_xdg_positioner_desc Description
 *
 * The xdg_positioner provides a collection of rules for the placement of a
 * child surface relative to a parent surface. Rules can be defined to ensure
 * the child surface remains within the visible area's borders.
 * @section page_iface_xdg_positioner_api API
 * See @ref iface_xdg_positioner.
 */
/**
 * @defgroup iface_xdg_positioner The xdg_positioner interface
 *
 * The xdg_positioner provides a collection of rules for the placement of a
 * child surface relative to a parent surface. Rules can be defined to ensure
 * the child surface remains within the visible area's borders.
 */
extern const struct wl_interface xdg_positioner_interface;
#endif
#ifndef XDG_SURFACE_INTERFACE
#define XDG_SURFACE_INTERFACE
/**
 * @page page_iface_xdg_surface xdg_surface
 * @section page_iface_xdg_surface_desc Description
 *
 * An interface that may be implemented by a wl_surface, for
 * implementations that provide a desktop-style user interface.
 * @section page_iface_xdg_surface_api API
 * See @ref iface_xdg_surface.
 */
/**
 * @defgroup iface_xdg_surface The xdg_surface interface
 *
 * An interface that may be implemented by a wl_surface, for
 * implementations that provide a desktop-style user interface.
 */
extern const struct wl_interface xdg_surface_interface;
#endif
#ifndef XDG_TOPLEVEL_INTERFACE
#define XDG_TOPLEVEL_INTERFACE
/**
 * @page page_iface_xdg_toplevel xdg_toplevel
 * @section page_iface_xdg_toplevel_desc Description
 *
 * This interface defines an xdg_surface role which allows a surface to,
 * among other things, set window-like properties such as maximize,
 * fullscreen, and minimize, set application-specific IDs like title and
 * id, and be well managed by the compositor.
 *
 * Client-provided data (title, app ID) is minimal state that persists
 * across surface configuration changes. The compositor may cache these
 * values and display them to the user.
 *
 * For a surface to be mapped as an xdg_toplevel, it must have the
 * xdg_toplevel role assigned. For a mapped xdg_toplevel, it must be given
 * a extent by the compositor via a configure event. The actual window
 * geometry does not include the window manager decorations (such as
 * shadows, title bars, and borders), but it does include client-side
 * decorations.
 *
 * The width and height in the configure event are multiples of 1 logical
 * pixel. The client is free to choose its own buffer size and scale, but
 * it must honor the configure event's size if it wishes to avoid scaling
 * issues.
 * @section page_iface_xdg_toplevel_api API
 * See @ref iface_xdg_toplevel.
 */
/**
 * @defgroup iface_xdg_toplevel The xdg_toplevel interface
 *
 * This interface defines an xdg_surface role which allows a surface to,
 * among other things, set window-like properties such as maximize,
 * fullscreen, and minimize, set application-specific IDs like title and
 * id, and be well managed by the compositor.
 *
 * Client-provided data (title, app ID) is minimal state that persists
 * across surface configuration changes. The compositor may cache these
 * values and display them to the user.
 *
 * For a surface to be mapped as an xdg_toplevel, it must have the
 * xdg_toplevel role assigned. For a mapped xdg_toplevel, it must be given
 * a extent by the compositor via a configure event. The actual window
 * geometry does not include the window manager decorations (such as
 * shadows, title bars, and borders), but it does include client-side
 * decorations.
 *
 * The width and height in the configure event are multiples of 1 logical
 * pixel. The client is free to choose its own buffer size and scale, but
 * it must honor the configure event's size if it wishes to avoid scaling
 * issues.
 */
extern const struct wl_interface xdg_toplevel_interface;
#endif
#ifndef XDG_POPUP_INTERFACE
#define XDG_POPUP_INTERFACE
/**
 * @page page_iface_xdg_popup xdg_popup
 * @section page_iface_xdg_popup_desc Description
 *
 * A popup surface is a short-lived, temporary surface. It can be used to
 * implement for example menus, popovers, tooltips and other similar user
 * interface concepts.
 *
 * A popup must have a parent surface associated with it. The parent surface
 * can be another popup or an xdg_toplevel. An xdg_popup is automatically
 * stacked above its parent as long as it is mapped.
 *
 * When a popup is unmapped, it is destroyed. This includes the case where
 * its parent surface is destroyed.
 *
 * A popup can be made modal by setting an optional grab on the seat. In
 * that case, the popup will receive all input events from the seat. The
 * compositor must ignore all input events from other surfaces (including
 * the parent) while the popup grab is active.
 *
 * When a popup is created, it must be configured before it can be mapped.
 * The compositor will send a configure event with the initial size. The
 * client should not commit a buffer until it has received the configure
 * event.
 *
 * A popup does not have a configure request to change its geometry.
 * Instead, it is destroyed and re-created with a new positioner if the
 * geometry changes.
 * @section page_iface_xdg_popup_api API
 * See @ref iface_xdg_popup.
 */
/**
 * @defgroup iface_xdg_popup The xdg_popup interface
 *
 * A popup surface is a short-lived, temporary surface. It can be used to
 * implement for example menus, popovers, tooltips and other similar user
 * interface concepts.
 *
 * A popup must have a parent surface associated with it. The parent surface
 * can be another popup or an xdg_toplevel. An xdg_popup is automatically
 * stacked above its parent as long as it is mapped.
 *
 * When a popup is unmapped, it is destroyed. This includes the case where
 * its parent surface is destroyed.
 *
 * A popup can be made modal by setting an optional grab on the seat. In
 * that case, the popup will receive all input events from the seat. The
 * compositor must ignore all input events from other surfaces (including
 * the parent) while the popup grab is active.
 *
 * When a popup is created, it must be configured before it can be mapped.
 * The compositor will send a configure event with the initial size. The
 * client should not commit a buffer until it has received the configure
 * event.
 *
 * A popup does not have a configure request to change its geometry.
 * Instead, it is destroyed and re-created with a new positioner if the
 * geometry changes.
 */
extern const struct wl_interface xdg_popup_interface;
#endif

#ifndef XDG_WM_BASE_ERROR_ENUM
#define XDG_WM_BASE_ERROR_ENUM
/**
 * @ingroup iface_xdg_wm_base
 * errors
 *
 * These errors can be emitted in response to xdg_wm_base requests.
 */
enum xdg_wm_base_error {
	/**
	 * given wl_surface has another role
	 */
	XDG_WM_BASE_ERROR_ROLE = 0,
	/**
	 * xdg_wm_base was destroyed before children
	 */
	XDG_WM_BASE_ERROR_DEFUNCT_SURFACES = 1,
	/**
	 * the client tried to map or destroy a non-topmost popup
	 */
	XDG_WM_BASE_ERROR_NOT_THE_TOPMOST_POPUP = 2,
	/**
	 * the client specified an invalid popup family
	 */
	XDG_WM_BASE_ERROR_INVALID_POPUP_FAMILY = 3,
	/**
	 * the client provided an invalid surface state
	 */
	XDG_WM_BASE_ERROR_INVALID_SURFACE_STATE = 4,
	/**
	 * the client provided an invalid positioner
	 */
	XDG_WM_BASE_ERROR_INVALID_POSITIONER = 5,
};
#endif /* XDG_WM_BASE_ERROR_ENUM */

/**
 * @ingroup iface_xdg_wm_base
 * @struct xdg_wm_base_listener
 */
struct xdg_wm_base_listener {
	/**
	 * check if the client is alive
	 *
	 * The ping event asks the client if it's alive. To pass the ping
	 * the client must call the pong request now or as soon as
	 * possible. If the client does not respond to enough pings, the
	 * compositor may assume the client is dead and destroy its
	 * surfaces.
	 * @param serial pass this to the pong request
	 */
	void (*ping)(void *data,
		     struct xdg_wm_base *xdg_wm_base,
		     uint32_t serial);
};

/**
 * @ingroup iface_xdg_wm_base
 */
static inline int
xdg_wm_base_add_listener(struct xdg_wm_base *xdg_wm_base,
			 const struct xdg_wm_base_listener *listener, void *data)
{
	return wl_proxy_add_listener((struct wl_proxy *) xdg_wm_base,
				     (void (**)(void)) listener, data);
}

#define XDG_WM_BASE_DESTROY 0
#define XDG_WM_BASE_CREATE_POSITIONER 1
#define XDG_WM_BASE_GET_XDG_SURFACE 2
#define XDG_WM_BASE_PONG 3

/**
 * @ingroup iface_xdg_wm_base
 */
#define XDG_WM_BASE_PING_SINCE_VERSION 1

/**
 * @ingroup iface_xdg_wm_base
 */
static inline void
xdg_wm_base_set_user_data(struct xdg_wm_base *xdg_wm_base, void *user_data)
{
	wl_proxy_set_user_data((struct wl_proxy *) xdg_wm_base, user_data);
}

/**
 * @ingroup iface_xdg_wm_base
 */
static inline void *
xdg_wm_base_get_user_data(struct xdg_wm_base *xdg_wm_base)
{
	return wl_proxy_get_user_data((struct wl_proxy *) xdg_wm_base);
}

static inline uint32_t
xdg_wm_base_get_version(struct xdg_wm_base *xdg_wm_base)
{
	return wl_proxy_get_version((struct wl_proxy *) xdg_wm_base);
}

/**
 * @ingroup iface_xdg_wm_base
 *
 * Destroy this xdg_wm_base object.
 */
static inline void
xdg_wm_base_destroy(struct xdg_wm_base *xdg_wm_base)
{
	wl_proxy_marshal_flags((struct wl_proxy *) xdg_wm_base,
			 XDG_WM_BASE_DESTROY, NULL, wl_proxy_get_version((struct wl_proxy *) xdg_wm_base), WL_MARSHAL_FLAG_DESTROY);
}

/**
 * @ingroup iface_xdg_wm_base
 *
 * Create a positioner object. A positioner object is used to position
 * surfaces relative to some parent surface.
 */
static inline struct xdg_positioner *
xdg_wm_base_create_positioner(struct xdg_wm_base *xdg_wm_base)
{
	struct wl_proxy *id;

	id = wl_proxy_marshal_flags((struct wl_proxy *) xdg_wm_base,
			 XDG_WM_BASE_CREATE_POSITIONER, &xdg_positioner_interface, wl_proxy_get_version((struct wl_proxy *) xdg_wm_base), 0, NULL);

	return (struct xdg_positioner *) id;
}

/**
 * @ingroup iface_xdg_wm_base
 *
 * This creates an xdg_surface for the given surface. While xdg_surface
 * itself is not a role, the corresponding surface may only be assigned
 * a role extending xdg_surface, such as xdg_toplevel or xdg_popup.
 */
static inline struct xdg_surface *
xdg_wm_base_get_xdg_surface(struct xdg_wm_base *xdg_wm_base, struct wl_surface *surface)
{
	struct wl_proxy *id;

	id = wl_proxy_marshal_flags((struct wl_proxy *) xdg_wm_base,
			 XDG_WM_BASE_GET_XDG_SURFACE, &xdg_surface_interface, wl_proxy_get_version((struct wl_proxy *) xdg_wm_base), 0, NULL, surface);

	return (struct xdg_surface *) id;
}

/**
 * @ingroup iface_xdg_wm_base
 *
 * A client must respond to a ping event with a pong request or
 * the client may be deemed unresponsive.
 */
static inline void
xdg_wm_base_pong(struct xdg_wm_base *xdg_wm_base, uint32_t serial)
{
	wl_proxy_marshal_flags((struct wl_proxy *) xdg_wm_base,
			 XDG_WM_BASE_PONG, NULL, wl_proxy_get_version((struct wl_proxy *) xdg_wm_base), 0, serial);
}

#ifndef XDG_POSITIONER_ERROR_ENUM
#define XDG_POSITIONER_ERROR_ENUM
/**
 * @ingroup iface_xdg_positioner
 * errors
 */
enum xdg_positioner_error {
	/**
	 * invalid input provided
	 */
	XDG_POSITIONER_ERROR_INVALID_INPUT = 0,
};
#endif /* XDG_POSITIONER_ERROR_ENUM */

#ifndef XDG_POSITIONER_ANCHOR_ENUM
#define XDG_POSITIONER_ANCHOR_ENUM
/**
 * @ingroup iface_xdg_positioner
 * anchor values
 */
enum xdg_positioner_anchor {
	XDG_POSITIONER_ANCHOR_NONE = 0,
	XDG_POSITIONER_ANCHOR_TOP = 1,
	XDG_POSITIONER_ANCHOR_BOTTOM = 2,
	XDG_POSITIONER_ANCHOR_LEFT = 4,
	XDG_POSITIONER_ANCHOR_RIGHT = 8,
};
#endif /* XDG_POSITIONER_ANCHOR_ENUM */

#ifndef XDG_POSITIONER_GRAVITY_ENUM
#define XDG_POSITIONER_GRAVITY_ENUM
/**
 * @ingroup iface_xdg_positioner
 * gravity values
 */
enum xdg_positioner_gravity {
	XDG_POSITIONER_GRAVITY_NONE = 0,
	XDG_POSITIONER_GRAVITY_TOP = 1,
	XDG_POSITIONER_GRAVITY_BOTTOM = 2,
	XDG_POSITIONER_GRAVITY_LEFT = 4,
	XDG_POSITIONER_GRAVITY_RIGHT = 8,
};
#endif /* XDG_POSITIONER_GRAVITY_ENUM */

#ifndef XDG_POSITIONER_CONSTRAINT_ADJUSTMENT_ENUM
#define XDG_POSITIONER_CONSTRAINT_ADJUSTMENT_ENUM
/**
 * @ingroup iface_xdg_positioner
 * constraint adjustments
 *
 * The constraint adjustment value define ways the compositor will adjust
 * the position of the surface to avoid constraints.
 */
enum xdg_positioner_constraint_adjustment {
	/**
	 * don't adjust the position
	 */
	XDG_POSITIONER_CONSTRAINT_ADJUSTMENT_NONE = 0,
	/**
	 * allow sliding horizontally
	 */
	XDG_POSITIONER_CONSTRAINT_ADJUSTMENT_SLIDE_X = 1,
	/**
	 * allow sliding vertically
	 */
	XDG_POSITIONER_CONSTRAINT_ADJUSTMENT_SLIDE_Y = 2,
	/**
	 * allow flipping horizontally
	 */
	XDG_POSITIONER_CONSTRAINT_ADJUSTMENT_FLIP_X = 4,
	/**
	 * allow flipping vertically
	 */
	XDG_POSITIONER_CONSTRAINT_ADJUSTMENT_FLIP_Y = 8,
	/**
	 * allow resizing horizontally
	 */
	XDG_POSITIONER_CONSTRAINT_ADJUSTMENT_RESIZE_X = 16,
	/**
	 * allow resizing vertically
	 */
	XDG_POSITIONER_CONSTRAINT_ADJUSTMENT_RESIZE_Y = 32,
};
#endif /* XDG_POSITIONER_CONSTRAINT_ADJUSTMENT_ENUM */

#define XDG_POSITIONER_DESTROY 0
#define XDG_POSITIONER_SET_SIZE 1
#define XDG_POSITIONER_SET_ANCHOR_RECT 2
#define XDG_POSITIONER_SET_ANCHOR 3
#define XDG_POSITIONER_SET_GRAVITY 4
#define XDG_POSITIONER_SET_CONSTRAINT_ADJUSTMENT 5
#define XDG_POSITIONER_SET_OFFSET 6
#define XDG_POSITIONER_SET_REACTIVE 7
#define XDG_POSITIONER_SET_PARENT_SIZE 8
#define XDG_POSITIONER_SET_PARENT_CONFIGURE 9


/**
 * @ingroup iface_xdg_positioner
 */
#define XDG_POSITIONER_SET_REACTIVE_SINCE_VERSION 3
/**
 * @ingroup iface_xdg_positioner
 */
#define XDG_POSITIONER_SET_PARENT_SIZE_SINCE_VERSION 3
/**
 * @ingroup iface_xdg_positioner
 */
#define XDG_POSITIONER_SET_PARENT_CONFIGURE_SINCE_VERSION 3


/**
 * @ingroup iface_xdg_positioner
 */
static inline void
xdg_positioner_set_user_data(struct xdg_positioner *xdg_positioner, void *user_data)
{
	wl_proxy_set_user_data((struct wl_proxy *) xdg_positioner, user_data);
}

/**
 * @ingroup iface_xdg_positioner
 */
static inline void *
xdg_positioner_get_user_data(struct xdg_positioner *xdg_positioner)
{
	return wl_proxy_get_user_data((struct wl_proxy *) xdg_positioner);
}

static inline uint32_t
xdg_positioner_get_version(struct xdg_positioner *xdg_positioner)
{
	return wl_proxy_get_version((struct wl_proxy *) xdg_positioner);
}

/**
 * @ingroup iface_xdg_positioner
 *
 * Destroy the xdg_positioner object.
 */
static inline void
xdg_positioner_destroy(struct xdg_positioner *xdg_positioner)
{
	wl_proxy_marshal_flags((struct wl_proxy *) xdg_positioner,
			 XDG_POSITIONER_DESTROY, NULL, wl_proxy_get_version((struct wl_proxy *) xdg_positioner), WL_MARSHAL_FLAG_DESTROY);
}

/**
 * @ingroup iface_xdg_positioner
 *
 * Set the size of the surface that is to be positioned.
 */
static inline void
xdg_positioner_set_size(struct xdg_positioner *xdg_positioner, int32_t width, int32_t height)
{
	wl_proxy_marshal_flags((struct wl_proxy *) xdg_positioner,
			 XDG_POSITIONER_SET_SIZE, NULL, wl_proxy_get_version((struct wl_proxy *) xdg_positioner), 0, width, height);
}

/**
 * @ingroup iface_xdg_positioner
 *
 * Specify the anchor rectangle within the parent surface that the child
 * surface will be placed relative to.
 */
static inline void
xdg_positioner_set_anchor_rect(struct xdg_positioner *xdg_positioner, int32_t x, int32_t y, int32_t width, int32_t height)
{
	wl_proxy_marshal_flags((struct wl_proxy *) xdg_positioner,
			 XDG_POSITIONER_SET_ANCHOR_RECT, NULL, wl_proxy_get_version((struct wl_proxy *) xdg_positioner), 0, x, y, width, height);
}

/**
 * @ingroup iface_xdg_positioner
 *
 * Defines which edge of the anchor rectangle is at the same position
 * as the surface.
 */
static inline void
xdg_positioner_set_anchor(struct xdg_positioner *xdg_positioner, uint32_t anchor)
{
	wl_proxy_marshal_flags((struct wl_proxy *) xdg_positioner,
			 XDG_POSITIONER_SET_ANCHOR, NULL, wl_proxy_get_version((struct wl_proxy *) xdg_positioner), 0, anchor);
}

/**
 * @ingroup iface_xdg_positioner
 *
 * Defines in what direction a surface should be positioned relative to
 * the anchor point of the parent surface.
 */
static inline void
xdg_positioner_set_gravity(struct xdg_positioner *xdg_positioner, uint32_t gravity)
{
	wl_proxy_marshal_flags((struct wl_proxy *) xdg_positioner,
			 XDG_POSITIONER_SET_GRAVITY, NULL, wl_proxy_get_version((struct wl_proxy *) xdg_positioner), 0, gravity);
}

/**
 * @ingroup iface_xdg_positioner
 *
 * Specify how the window should be positioned if it would otherwise
 * move off the visible area.
 */
static inline void
xdg_positioner_set_constraint_adjustment(struct xdg_positioner *xdg_positioner, uint32_t constraint_adjustment)
{
	wl_proxy_marshal_flags((struct wl_proxy *) xdg_positioner,
			 XDG_POSITIONER_SET_CONSTRAINT_ADJUSTMENT, NULL, wl_proxy_get_version((struct wl_proxy *) xdg_positioner), 0, constraint_adjustment);
}

/**
 * @ingroup iface_xdg_positioner
 *
 * Specify the surface position offset relative to the position of the
 * anchor on the anchor rectangle and the anchor on the surface.
 */
static inline void
xdg_positioner_set_offset(struct xdg_positioner *xdg_positioner, int32_t x, int32_t y)
{
	wl_proxy_marshal_flags((struct wl_proxy *) xdg_positioner,
			 XDG_POSITIONER_SET_OFFSET, NULL, wl_proxy_get_version((struct wl_proxy *) xdg_positioner), 0, x, y);
}

/**
 * @ingroup iface_xdg_positioner
 *
 * When set reactive, the surface is reconstrained if the conditions used
 * for positioning change.
 */
static inline void
xdg_positioner_set_reactive(struct xdg_positioner *xdg_positioner)
{
	wl_proxy_marshal_flags((struct wl_proxy *) xdg_positioner,
			 XDG_POSITIONER_SET_REACTIVE, NULL, wl_proxy_get_version((struct wl_proxy *) xdg_positioner), 0);
}

/**
 * @ingroup iface_xdg_positioner
 */
static inline void
xdg_positioner_set_parent_size(struct xdg_positioner *xdg_positioner, int32_t parent_width, int32_t parent_height)
{
	wl_proxy_marshal_flags((struct wl_proxy *) xdg_positioner,
			 XDG_POSITIONER_SET_PARENT_SIZE, NULL, wl_proxy_get_version((struct wl_proxy *) xdg_positioner), 0, parent_width, parent_height);
}

/**
 * @ingroup iface_xdg_positioner
 */
static inline void
xdg_positioner_set_parent_configure(struct xdg_positioner *xdg_positioner, uint32_t serial)
{
	wl_proxy_marshal_flags((struct wl_proxy *) xdg_positioner,
			 XDG_POSITIONER_SET_PARENT_CONFIGURE, NULL, wl_proxy_get_version((struct wl_proxy *) xdg_positioner), 0, serial);
}

#ifndef XDG_SURFACE_ERROR_ENUM
#define XDG_SURFACE_ERROR_ENUM
/**
 * @ingroup iface_xdg_surface
 * errors
 */
enum xdg_surface_error {
	/**
	 * Surface was not fully constructed
	 */
	XDG_SURFACE_ERROR_NOT_CONSTRUCTED = 1,
	/**
	 * Surface was already constructed
	 */
	XDG_SURFACE_ERROR_ALREADY_CONSTRUCTED = 2,
	/**
	 * Attaching a buffer to an unconfigured surface
	 */
	XDG_SURFACE_ERROR_UNCONFIGURED_BUFFER = 3,
};
#endif /* XDG_SURFACE_ERROR_ENUM */

/**
 * @ingroup iface_xdg_surface
 * @struct xdg_surface_listener
 */
struct xdg_surface_listener {
	/**
	 * suggest a surface change
	 *
	 * The configure event asks the client to change its surface
	 * state.
	 *
	 * The client must apply the configure state changes to its
	 * surface state and commit the surface to apply the changes.
	 *
	 * The configure event may be sent at any time, but the client
	 * must not make any assumptions about the order of configure
	 * events.
	 *
	 * The serial number is used to acknowledge the configure event.
	 * @param serial serial of the configure event
	 */
	void (*configure)(void *data,
			  struct xdg_surface *xdg_surface,
			  uint32_t serial);
};

/**
 * @ingroup iface_xdg_surface
 */
static inline int
xdg_surface_add_listener(struct xdg_surface *xdg_surface,
			 const struct xdg_surface_listener *listener, void *data)
{
	return wl_proxy_add_listener((struct wl_proxy *) xdg_surface,
				     (void (**)(void)) listener, data);
}

#define XDG_SURFACE_DESTROY 0
#define XDG_SURFACE_GET_TOPLEVEL 1
#define XDG_SURFACE_GET_POPUP 2
#define XDG_SURFACE_ACK_CONFIGURE 3

/**
 * @ingroup iface_xdg_surface
 */
#define XDG_SURFACE_CONFIGURE_SINCE_VERSION 1

/**
 * @ingroup iface_xdg_surface
 */
static inline void
xdg_surface_set_user_data(struct xdg_surface *xdg_surface, void *user_data)
{
	wl_proxy_set_user_data((struct wl_proxy *) xdg_surface, user_data);
}

/**
 * @ingroup iface_xdg_surface
 */
static inline void *
xdg_surface_get_user_data(struct xdg_surface *xdg_surface)
{
	return wl_proxy_get_user_data((struct wl_proxy *) xdg_surface);
}

static inline uint32_t
xdg_surface_get_version(struct xdg_surface *xdg_surface)
{
	return wl_proxy_get_version((struct wl_proxy *) xdg_surface);
}

/**
 * @ingroup iface_xdg_surface
 *
 * Destroy the xdg_surface object. An xdg_surface must only be destroyed
 * after its role object has been destroyed.
 */
static inline void
xdg_surface_destroy(struct xdg_surface *xdg_surface)
{
	wl_proxy_marshal_flags((struct wl_proxy *) xdg_surface,
			 XDG_SURFACE_DESTROY, NULL, wl_proxy_get_version((struct wl_proxy *) xdg_surface), WL_MARSHAL_FLAG_DESTROY);
}

/**
 * @ingroup iface_xdg_surface
 *
 * This creates an xdg_toplevel object for the given xdg_surface and gives
 * the associated wl_surface the xdg_toplevel role.
 */
static inline struct xdg_toplevel *
xdg_surface_get_toplevel(struct xdg_surface *xdg_surface)
{
	struct wl_proxy *id;

	id = wl_proxy_marshal_flags((struct wl_proxy *) xdg_surface,
			 XDG_SURFACE_GET_TOPLEVEL, &xdg_toplevel_interface, wl_proxy_get_version((struct wl_proxy *) xdg_surface), 0, NULL);

	return (struct xdg_toplevel *) id;
}

/**
 * @ingroup iface_xdg_surface
 *
 * This creates an xdg_popup object for the given xdg_surface and gives
 * the associated wl_surface the xdg_popup role.
 */
static inline struct xdg_popup *
xdg_surface_get_popup(struct xdg_surface *xdg_surface, struct xdg_surface *parent, struct xdg_positioner *positioner)
{
	struct wl_proxy *id;

	id = wl_proxy_marshal_flags((struct wl_proxy *) xdg_surface,
			 XDG_SURFACE_GET_POPUP, &xdg_popup_interface, wl_proxy_get_version((struct wl_proxy *) xdg_surface), 0, NULL, parent, positioner);

	return (struct xdg_popup *) id;
}

/**
 * @ingroup iface_xdg_surface
 *
 * When a configure event is received, the client must send an
 * ack_configure with the serial from the event to acknowledge that the
 * configuration has been applied.
 *
 * If a client commits a buffer on a surface with a configure event that
 * has not been acknowledged, the compositor may discard the buffer.
 *
 * A client should not send a configure acknowledgement for a configure
 * event that has already been acknowledged.
 *
 * If the configure event carries a non-zero serial and the client does
 * not send an ack_configure request before the next commit, the compositor
 * may assume that the client is not using the serial and may ignore
 * future configure events with a zero serial.
 */
static inline void
xdg_surface_ack_configure(struct xdg_surface *xdg_surface, uint32_t serial)
{
	wl_proxy_marshal_flags((struct wl_proxy *) xdg_surface,
			 XDG_SURFACE_ACK_CONFIGURE, NULL, wl_proxy_get_version((struct wl_proxy *) xdg_surface), 0, serial);
}

#ifndef XDG_TOPLEVEL_RESIZE_EDGE_ENUM
#define XDG_TOPLEVEL_RESIZE_EDGE_ENUM
/**
 * @ingroup iface_xdg_toplevel
 * edge values for resizing
 *
 * These values are used to indicate which edge of a surface is being
 * dragged in a resize operation.
 */
enum xdg_toplevel_resize_edge {
	XDG_TOPLEVEL_RESIZE_EDGE_NONE = 0,
	XDG_TOPLEVEL_RESIZE_EDGE_TOP = 1,
	XDG_TOPLEVEL_RESIZE_EDGE_BOTTOM = 2,
	XDG_TOPLEVEL_RESIZE_EDGE_LEFT = 4,
	XDG_TOPLEVEL_RESIZE_EDGE_TOP_LEFT = 5,
	XDG_TOPLEVEL_RESIZE_EDGE_BOTTOM_LEFT = 6,
	XDG_TOPLEVEL_RESIZE_EDGE_RIGHT = 8,
	XDG_TOPLEVEL_RESIZE_EDGE_TOP_RIGHT = 9,
	XDG_TOPLEVEL_RESIZE_EDGE_BOTTOM_RIGHT = 10,
};
#endif /* XDG_TOPLEVEL_RESIZE_EDGE_ENUM */

#ifndef XDG_TOPLEVEL_STATE_ENUM
#define XDG_TOPLEVEL_STATE_ENUM
/**
 * @ingroup iface_xdg_toplevel
 * types of state on the surface
 *
 * The different state values used in the configure event. The states are
 * used to indicate how the surface should be displayed.
 */
enum xdg_toplevel_state {
	/**
	 * the surface is maximized
	 */
	XDG_TOPLEVEL_STATE_MAXIMIZED = 1,
	/**
	 * the surface is fullscreen
	 */
	XDG_TOPLEVEL_STATE_FULLSCREEN = 2,
	/**
	 * the surface is being resized
	 */
	XDG_TOPLEVEL_STATE_RESIZING = 3,
	/**
	 * the surface is activated
	 */
	XDG_TOPLEVEL_STATE_ACTIVATED = 4,
	/**
	 * the surface is tiled
	 */
	XDG_TOPLEVEL_STATE_TILED_LEFT = 5,
	/**
	 * the surface is tiled
	 */
	XDG_TOPLEVEL_STATE_TILED_RIGHT = 6,
	/**
	 * the surface is tiled
	 */
	XDG_TOPLEVEL_STATE_TILED_TOP = 7,
	/**
	 * the surface is tiled
	 */
	XDG_TOPLEVEL_STATE_TILED_BOTTOM = 8,
	/**
	 * since 6
	 */
	XDG_TOPLEVEL_STATE_SUSPENDED = 9,
};
#endif /* XDG_TOPLEVEL_STATE_ENUM */

#ifndef XDG_TOPLEVEL_WM_CAPABILITIES_ENUM
#define XDG_TOPLEVEL_WM_CAPABILITIES_ENUM
/**
 * @ingroup iface_xdg_toplevel
 * compositor capabilities
 *
 * This enum describes the capabilities of the compositor that could
 * be useful to the client.
 */
enum xdg_toplevel_wm_capabilities {
	/**
	 * show window menu
	 */
	XDG_TOPLEVEL_WM_CAPABILITIES_WINDOW_MENU = 1,
	/**
	 * maximize window
	 */
	XDG_TOPLEVEL_WM_CAPABILITIES_MAXIMIZE = 2,
	/**
	 * fullscreen window
	 */
	XDG_TOPLEVEL_WM_CAPABILITIES_FULLSCREEN = 3,
	/**
	 * minimize window
	 */
	XDG_TOPLEVEL_WM_CAPABILITIES_MINIMIZE = 4,
};
#endif /* XDG_TOPLEVEL_WM_CAPABILITIES_ENUM */

/**
 * @ingroup iface_xdg_toplevel
 * @struct xdg_toplevel_listener
 */
struct xdg_toplevel_listener {
	/**
	 * suggest a surface change
	 *
	 * This configure event asks the client to resize its toplevel
	 * surface or to change its state.
	 *
	 * The width and height are in units of logical pixels. The
	 * configure event should be used together with an
	 * xdg_surface.configure event.
	 *
	 * The client should arrange for its surface to have the given
	 * dimensions and to be drawn with the given state. If the width
	 * and height are zero, the client should decide its own
	 * dimensions.
	 *
	 * The client must not call wl_surface_commit on the associated
	 * wl_surface until the configure event has been acknowledged by
	 * calling xdg_surface.ack_configure.
	 *
	 * The states are listed in an array. The array is a list of
	 * states that will be applied after the size has been set.
	 * @param width width of the surface in logical pixels
	 * @param height height of the surface in logical pixels
	 * @param states array of states
	 */
	void (*configure)(void *data,
			  struct xdg_toplevel *xdg_toplevel,
			  int32_t width,
			  int32_t height,
			  struct wl_array *states);
	/**
	 * surface wants to be closed
	 *
	 * The close event is sent by the compositor when the user wants
	 * the surface to be closed. This should be equivalent to the user
	 * clicking the close button in client-side decorations, if your
	 * application has any.
	 *
	 * This is only a request that the client should take care of
	 * destroying the window. The client may ignore the close request
	 * if it has good reasons to do so.
	 */
	void (*close)(void *data,
		      struct xdg_toplevel *xdg_toplevel);
	/**
	 * recommended window geometry bounds
	 *
	 * The configure_bounds event may be sent as a reply to a
	 * request_bounds request or whenever the compositor has updated
	 * its preferences.
	 *
	 * The x and y arguments are ignored and should be treated as
	 * zero. The width and height arguments may be zero if the
	 * compositor has no valid data to provide. The compositor may
	 * also send a configure_bounds event with zero width and height
	 * when switching between different screens with different
	 * geometries.
	 *
	 * The bounds are for the window geometry. The window geometry is
	 * the area of the window where the application can render. The
	 * compositor does not have any extra decorations to consider.
	 * @param width maximum width in logical pixels
	 * @param height maximum height in logical pixels
	 * @since 6
	 */
	void (*configure_bounds)(void *data,
				 struct xdg_toplevel *xdg_toplevel,
				 int32_t width,
				 int32_t height);
	/**
	 * compositor capabilities
	 *
	 * This event advertises the capabilities supported by the
	 * compositor. If a capability is not supported, the client should
	 * hide or grey out the relevant UI elements.
	 * @param capabilities array of capabilities
	 * @since 6
	 */
	void (*wm_capabilities)(void *data,
				struct xdg_toplevel *xdg_toplevel,
				struct wl_array *capabilities);
};

/**
 * @ingroup iface_xdg_toplevel
 */
static inline int
xdg_toplevel_add_listener(struct xdg_toplevel *xdg_toplevel,
			  const struct xdg_toplevel_listener *listener, void *data)
{
	return wl_proxy_add_listener((struct wl_proxy *) xdg_toplevel,
				     (void (**)(void)) listener, data);
}

#define XDG_TOPLEVEL_DESTROY 0
#define XDG_TOPLEVEL_SET_PARENT 1
#define XDG_TOPLEVEL_SET_TITLE 2
#define XDG_TOPLEVEL_SET_APP_ID 3
#define XDG_TOPLEVEL_SHOW_WINDOW_MENU 4
#define XDG_TOPLEVEL_MOVE 5
#define XDG_TOPLEVEL_RESIZE 6
#define XDG_TOPLEVEL_SET_MAX_SIZE 7
#define XDG_TOPLEVEL_SET_MIN_SIZE 8
#define XDG_TOPLEVEL_SET_MAXIMIZED 9
#define XDG_TOPLEVEL_UNSET_MAXIMIZED 10
#define XDG_TOPLEVEL_SET_FULLSCREEN 11
#define XDG_TOPLEVEL_UNSET_FULLSCREEN 12
#define XDG_TOPLEVEL_SET_MINIMIZED 13
#define XDG_TOPLEVEL_REQUEST_BOUNDS 14

/**
 * @ingroup iface_xdg_toplevel
 */
#define XDG_TOPLEVEL_CONFIGURE_SINCE_VERSION 1
/**
 * @ingroup iface_xdg_toplevel
 */
#define XDG_TOPLEVEL_CLOSE_SINCE_VERSION 1
/**
 * @ingroup iface_xdg_toplevel
 */
#define XDG_TOPLEVEL_CONFIGURE_BOUNDS_SINCE_VERSION 6
/**
 * @ingroup iface_xdg_toplevel
 */
#define XDG_TOPLEVEL_WM_CAPABILITIES_SINCE_VERSION 6

/**
 * @ingroup iface_xdg_toplevel
 */
#define XDG_TOPLEVEL_REQUEST_BOUNDS_SINCE_VERSION 6

/**
 * @ingroup iface_xdg_toplevel
 */
static inline void
xdg_toplevel_set_user_data(struct xdg_toplevel *xdg_toplevel, void *user_data)
{
	wl_proxy_set_user_data((struct wl_proxy *) xdg_toplevel, user_data);
}

/**
 * @ingroup iface_xdg_toplevel
 */
static inline void *
xdg_toplevel_get_user_data(struct xdg_toplevel *xdg_toplevel)
{
	return wl_proxy_get_user_data((struct wl_proxy *) xdg_toplevel);
}

static inline uint32_t
xdg_toplevel_get_version(struct xdg_toplevel *xdg_toplevel)
{
	return wl_proxy_get_version((struct wl_proxy *) xdg_toplevel);
}

/**
 * @ingroup iface_xdg_toplevel
 *
 * This request destroys the role object. The xdg_surface bound to this
 * role must be destroyed as well, or the xdg_surface will outlive the
 * role object and the compositor must not use it after it is destroyed.
 */
static inline void
xdg_toplevel_destroy(struct xdg_toplevel *xdg_toplevel)
{
	wl_proxy_marshal_flags((struct wl_proxy *) xdg_toplevel,
			 XDG_TOPLEVEL_DESTROY, NULL, wl_proxy_get_version((struct wl_proxy *) xdg_toplevel), WL_MARSHAL_FLAG_DESTROY);
}

/**
 * @ingroup iface_xdg_toplevel
 *
 * Set the parent of this surface. Setting the parent to NULL makes this
 * surface a top-level surface.
 *
 * This surface must be mapped as a toplevel before setting the parent.
 * The parent surface must be mapped as a toplevel as well.
 */
static inline void
xdg_toplevel_set_parent(struct xdg_toplevel *xdg_toplevel, struct xdg_toplevel *parent)
{
	wl_proxy_marshal_flags((struct wl_proxy *) xdg_toplevel,
			 XDG_TOPLEVEL_SET_PARENT, NULL, wl_proxy_get_version((struct wl_proxy *) xdg_toplevel), 0, parent);
}

/**
 * @ingroup iface_xdg_toplevel
 *
 * Set a short title for the surface.
 *
 * This string may be used to identify the surface in a task bar, window
 * list, or other user interface elements related to the window manager
 * window.
 *
 * The string must be encoded in UTF-8.
 */
static inline void
xdg_toplevel_set_title(struct xdg_toplevel *xdg_toplevel, const char *title)
{
	wl_proxy_marshal_flags((struct wl_proxy *) xdg_toplevel,
			 XDG_TOPLEVEL_SET_TITLE, NULL, wl_proxy_get_version((struct wl_proxy *) xdg_toplevel), 0, title);
}

/**
 * @ingroup iface_xdg_toplevel
 *
 * Set an application identifier for the surface.
 *
 * The app ID identifies the general class of applications to which the
 * surface belongs. The compositor can use this to group multiple surfaces
 * together, or to determine how to launch a new surface.
 *
 * The app ID must follow the rules for application IDs in the Desktop
 * Entry Specification, which are:
 *
 * - The application ID must contain only ASCII characters other than
 *   control characters, whitespace, and '/'.
 * - The application ID must contain at least one '.' separator.
 * - The application ID must not start or end with a '.'.
 * - The application ID must be unique.
 *
 * If the compositor cannot parse the application ID, it should treat it
 * as invalid and ignore it.
 *
 * The string must be encoded in UTF-8.
 */
static inline void
xdg_toplevel_set_app_id(struct xdg_toplevel *xdg_toplevel, const char *app_id)
{
	wl_proxy_marshal_flags((struct wl_proxy *) xdg_toplevel,
			 XDG_TOPLEVEL_SET_APP_ID, NULL, wl_proxy_get_version((struct wl_proxy *) xdg_toplevel), 0, app_id);
}

/**
 * @ingroup iface_xdg_toplevel
 *
 * Show the window menu at the given position.
 *
 * A window menu is a popup window that allows the user to control various
 * aspects of the window, such as maximizing, minimizing, moving,
 * resizing, or closing.
 *
 * The compositor can use the seat and serial to determine which input
 * device and event triggered the request.
 */
static inline void
xdg_toplevel_show_window_menu(struct xdg_toplevel *xdg_toplevel, struct wl_seat *seat, uint32_t serial, int32_t x, int32_t y)
{
	wl_proxy_marshal_flags((struct wl_proxy *) xdg_toplevel,
			 XDG_TOPLEVEL_SHOW_WINDOW_MENU, NULL, wl_proxy_get_version((struct wl_proxy *) xdg_toplevel), 0, seat, serial, x, y);
}

/**
 * @ingroup iface_xdg_toplevel
 *
 * Start an interactive move for the surface.
 *
 * The compositor can use the seat and serial to determine which input
 * device and event triggered the interactive move.
 *
 * The surface must be mapped before starting an interactive move.
 */
static inline void
xdg_toplevel_move(struct xdg_toplevel *xdg_toplevel, struct wl_seat *seat, uint32_t serial)
{
	wl_proxy_marshal_flags((struct wl_proxy *) xdg_toplevel,
			 XDG_TOPLEVEL_MOVE, NULL, wl_proxy_get_version((struct wl_proxy *) xdg_toplevel), 0, seat, serial);
}

/**
 * @ingroup iface_xdg_toplevel
 *
 * Start an interactive resize for the surface.
 *
 * The compositor can use the seat and serial to determine which input
 * device and event triggered the interactive resize.
 *
 * The surface must be mapped before starting an interactive resize.
 */
static inline void
xdg_toplevel_resize(struct xdg_toplevel *xdg_toplevel, struct wl_seat *seat, uint32_t serial, uint32_t edges)
{
	wl_proxy_marshal_flags((struct wl_proxy *) xdg_toplevel,
			 XDG_TOPLEVEL_RESIZE, NULL, wl_proxy_get_version((struct wl_proxy *) xdg_toplevel), 0, seat, serial, edges);
}

/**
 * @ingroup iface_xdg_toplevel
 *
 * Set a maximum size for the window.
 *
 * The client can specify a maximum size so that the compositor does not
 * try to resize the window larger than the given dimensions.
 *
 * The maximum size is a hint to the compositor. The compositor may ignore
 * it if it has good reasons to do so.
 *
 * If the maximum size is not set, or if the maximum size is set to zero,
 * the compositor may allow the window to be resized to any size.
 *
 * The values are in terms of logical pixels, not physical pixels. They
 * are not scaled by the output scale.
 */
static inline void
xdg_toplevel_set_max_size(struct xdg_toplevel *xdg_toplevel, int32_t width, int32_t height)
{
	wl_proxy_marshal_flags((struct wl_proxy *) xdg_toplevel,
			 XDG_TOPLEVEL_SET_MAX_SIZE, NULL, wl_proxy_get_version((struct wl_proxy *) xdg_toplevel), 0, width, height);
}

/**
 * @ingroup iface_xdg_toplevel
 *
 * Set a minimum size for the window.
 *
 * The client can specify a minimum size so that the compositor does not
 * try to resize the window smaller than the given dimensions.
 *
 * The minimum size is a hint to the compositor. The compositor may ignore
 * it if it has good reasons to do so.
 *
 * If the minimum size is not set, or if the minimum size is set to zero,
 * the compositor may allow the window to be resized to any size.
 *
 * The values are in terms of logical pixels, not physical pixels. They
 * are not scaled by the output scale.
 */
static inline void
xdg_toplevel_set_min_size(struct xdg_toplevel *xdg_toplevel, int32_t width, int32_t height)
{
	wl_proxy_marshal_flags((struct wl_proxy *) xdg_toplevel,
			 XDG_TOPLEVEL_SET_MIN_SIZE, NULL, wl_proxy_get_version((struct wl_proxy *) xdg_toplevel), 0, width, height);
}

/**
 * @ingroup iface_xdg_toplevel
 *
 * Maximize the surface.
 *
 * After requesting that the surface should be maximized, the compositor
 * will respond by emitting a configure event with the "maximized" state
 * and the window geometry set to the maximum size. The client should then
 * update its content accordingly.
 *
 * The compositor may still send configure events with other states even
 * after receiving a request to maximize. The client must not assume that
 * the maximize state is applied until it receives a configure event with
 * the maximize state.
 *
 * The client must call xdg_surface.ack_configure after the configure
 * event to acknowledge that it has applied the maximize state.
 *
 * The maximize state cannot be combined with the fullscreen state.
 */
static inline void
xdg_toplevel_set_maximized(struct xdg_toplevel *xdg_toplevel)
{
	wl_proxy_marshal_flags((struct wl_proxy *) xdg_toplevel,
			 XDG_TOPLEVEL_SET_MAXIMIZED, NULL, wl_proxy_get_version((struct wl_proxy *) xdg_toplevel), 0);
}

/**
 * @ingroup iface_xdg_toplevel
 *
 * Unmaximize the surface.
 *
 * After requesting that the surface should be unmaximized, the compositor
 * will respond by emitting a configure event without the "maximized"
 * state. The client should then update its content accordingly.
 *
 * The client must call xdg_surface.ack_configure after the configure
 * event to acknowledge that it has applied the unmaximize state.
 */
static inline void
xdg_toplevel_unset_maximized(struct xdg_toplevel *xdg_toplevel)
{
	wl_proxy_marshal_flags((struct wl_proxy *) xdg_toplevel,
			 XDG_TOPLEVEL_UNSET_MAXIMIZED, NULL, wl_proxy_get_version((struct wl_proxy *) xdg_toplevel), 0);
}

/**
 * @ingroup iface_xdg_toplevel
 *
 * Make the surface fullscreen.
 *
 * After requesting that the surface should be fullscreened, the
 * compositor will respond by emitting a configure event with the
 * "fullscreen" state and the window geometry set to the size of the given
 * output. The client should then update its content accordingly.
 *
 * The output parameter may be NULL. If the output is NULL, the compositor
 * will decide which output to use. If the output is non-NULL, the
 * compositor will use the given output to display the surface. The
 * compositor may still send configure events with other states even after
 * receiving a request to fullscreen. The client must not assume that the
 * fullscreen state is applied until it receives a configure event with
 * the fullscreen state.
 *
 * The client must call xdg_surface.ack_configure after the configure
 * event to acknowledge that it has applied the fullscreen state.
 *
 * The fullscreen state cannot be combined with the maximize state.
 */
static inline void
xdg_toplevel_set_fullscreen(struct xdg_toplevel *xdg_toplevel, struct wl_output *output)
{
	wl_proxy_marshal_flags((struct wl_proxy *) xdg_toplevel,
			 XDG_TOPLEVEL_SET_FULLSCREEN, NULL, wl_proxy_get_version((struct wl_proxy *) xdg_toplevel), 0, output);
}

/**
 * @ingroup iface_xdg_toplevel
 *
 * Unfullscreen the surface.
 *
 * After requesting that the surface should be unfullscreened, the
 * compositor will respond by emitting a configure event without the
 * "fullscreen" state. The client should then update its content
 * accordingly.
 *
 * The client must call xdg_surface.ack_configure after the configure
 * event to acknowledge that it has applied the unfullscreen state.
 */
static inline void
xdg_toplevel_unset_fullscreen(struct xdg_toplevel *xdg_toplevel)
{
	wl_proxy_marshal_flags((struct wl_proxy *) xdg_toplevel,
			 XDG_TOPLEVEL_UNSET_FULLSCREEN, NULL, wl_proxy_get_version((struct wl_proxy *) xdg_toplevel), 0);
}

/**
 * @ingroup iface_xdg_toplevel
 *
 * Request that the compositor minimize the surface.
 *
 * A minimized surface is typically not visible to the user and is often
 * represented by an icon in the task bar. The compositor may also provide
 * a method to unminimize the surface (e.g., by clicking the icon).
 *
 * There is no way to know if the surface is currently minimized, or when
 * the surface is unminimized.
 */
static inline void
xdg_toplevel_set_minimized(struct xdg_toplevel *xdg_toplevel)
{
	wl_proxy_marshal_flags((struct wl_proxy *) xdg_toplevel,
			 XDG_TOPLEVEL_SET_MINIMIZED, NULL, wl_proxy_get_version((struct wl_proxy *) xdg_toplevel), 0);
}

/**
 * @ingroup iface_xdg_toplevel
 *
 * Request the compositor to provide the preferred bounds for the window.
 * The compositor can respond by sending a configure_bounds event.
 *
 * The x and y arguments are ignored and should be set to zero.
 *
 * The client may request bounds at any time, but the compositor may delay
 * the response or ignore the request if it has no valid bounds to
 * provide.
 *
 * The compositor may also send a configure_bounds event without a
 * request, for example when switching between different screens.
 */
static inline void
xdg_toplevel_request_bounds(struct xdg_toplevel *xdg_toplevel, int32_t x, int32_t y, int32_t width, int32_t height)
{
	wl_proxy_marshal_flags((struct wl_proxy *) xdg_toplevel,
			 XDG_TOPLEVEL_REQUEST_BOUNDS, NULL, wl_proxy_get_version((struct wl_proxy *) xdg_toplevel), 0, x, y, width, height);
}

#ifndef XDG_POPUP_ERROR_ENUM
#define XDG_POPUP_ERROR_ENUM
/**
 * @ingroup iface_xdg_popup
 * errors
 */
enum xdg_popup_error {
	/**
	 * invalid xdg_popup family
	 */
	XDG_POPUP_ERROR_INVALID_GRAB = 0,
};
#endif /* XDG_POPUP_ERROR_ENUM */

/**
 * @ingroup iface_xdg_popup
 * @struct xdg_popup_listener
 */
struct xdg_popup_listener {
	/**
	 * configure the popup surface
	 *
	 * This event asks the popup surface to configure itself given
	 * the configuration. The configured state must be applied to the
	 * surface and committed immediately.
	 *
	 * The x, y, width, and height arguments are in surface-local
	 * coordinates. The x and y arguments represent the position of
	 * the popup relative to the parent surface.
	 *
	 * The width and height arguments represent the size of the popup.
	 *
	 * The serial is used to acknowledge the configure event. The
	 * client must call xdg_surface.ack_configure with this serial
	 * when applying the configuration.
	 * @param x x position relative to parent surface
	 * @param y y position relative to parent surface
	 * @param width width of the popup
	 * @param height height of the popup
	 * @param serial serial of the configure event
	 */
	void (*configure)(void *data,
			  struct xdg_popup *xdg_popup,
			  int32_t x,
			  int32_t y,
			  int32_t width,
			  int32_t height,
			  uint32_t serial);
	/**
	 * popup interaction is dismissed
	 *
	 * The popup_done event is sent out when a popup is dismissed by
	 * the compositor. The client should destroy the xdg_popup object
	 * at this point.
	 */
	void (*popup_done)(void *data,
			   struct xdg_popup *xdg_popup);
	/**
	 * the popup is repositioned
	 *
	 * The repositioned event is sent when the popup was repositioned
	 * as a result of its parent's geometry changes or other reasons.
	 *
	 * The serial is used to acknowledge the repositioning. The client
	 * should use the new positioner to recreate the popup and call
	 * xdg_surface.ack_configure with the serial when doing so.
	 * @param serial serial of the reposition event
	 * @since 6
	 */
	void (*repositioned)(void *data,
			     struct xdg_popup *xdg_popup,
			     uint32_t serial);
};

/**
 * @ingroup iface_xdg_popup
 */
static inline int
xdg_popup_add_listener(struct xdg_popup *xdg_popup,
		       const struct xdg_popup_listener *listener, void *data)
{
	return wl_proxy_add_listener((struct wl_proxy *) xdg_popup,
				     (void (**)(void)) listener, data);
}

#define XDG_POPUP_DESTROY 0
#define XDG_POPUP_GRAB 1
#define XDG_POPUP_REPOSITION 2

/**
 * @ingroup iface_xdg_popup
 */
#define XDG_POPUP_CONFIGURE_SINCE_VERSION 1
/**
 * @ingroup iface_xdg_popup
 */
#define XDG_POPUP_POPUP_DONE_SINCE_VERSION 1
/**
 * @ingroup iface_xdg_popup
 */
#define XDG_POPUP_REPOSITIONED_SINCE_VERSION 6

/**
 * @ingroup iface_xdg_popup
 */
#define XDG_POPUP_REPOSITION_SINCE_VERSION 6

/**
 * @ingroup iface_xdg_popup
 */
static inline void
xdg_popup_set_user_data(struct xdg_popup *xdg_popup, void *user_data)
{
	wl_proxy_set_user_data((struct wl_proxy *) xdg_popup, user_data);
}

/**
 * @ingroup iface_xdg_popup
 */
static inline void *
xdg_popup_get_user_data(struct xdg_popup *xdg_popup)
{
	return wl_proxy_get_user_data((struct wl_proxy *) xdg_popup);
}

static inline uint32_t
xdg_popup_get_version(struct xdg_popup *xdg_popup)
{
	return wl_proxy_get_version((struct wl_proxy *) xdg_popup);
}

/**
 * @ingroup iface_xdg_popup
 *
 * This destroys the popup. The xdg_popup object must be destroyed
 * before the xdg_surface object that it was created from.
 */
static inline void
xdg_popup_destroy(struct xdg_popup *xdg_popup)
{
	wl_proxy_marshal_flags((struct wl_proxy *) xdg_popup,
			 XDG_POPUP_DESTROY, NULL, wl_proxy_get_version((struct wl_proxy *) xdg_popup), WL_MARSHAL_FLAG_DESTROY);
}

/**
 * @ingroup iface_xdg_popup
 *
 * This request makes the popup take an explicit grab. An explicit grab
 * will be dismissed when the user clicks outside the popup.
 *
 * The compositor can use the seat and serial to determine which input
 * device and event triggered the grab.
 *
 * The popup must be mapped before making an explicit grab.
 */
static inline void
xdg_popup_grab(struct xdg_popup *xdg_popup, struct wl_seat *seat, uint32_t serial)
{
	wl_proxy_marshal_flags((struct wl_proxy *) xdg_popup,
			 XDG_POPUP_GRAB, NULL, wl_proxy_get_version((struct wl_proxy *) xdg_popup), 0, seat, serial);
}

/**
 * @ingroup iface_xdg_popup
 *
 * Reposition an already-mapped popup. The popup must have been created
 * with a reactive positioner.
 *
 * The parent and positioner arguments are the same as in
 * xdg_surface.get_popup. The popup must be destroyed and recreated if
 * the parent or positioner changes.
 */
static inline void
xdg_popup_reposition(struct xdg_popup *xdg_popup, struct xdg_positioner *positioner, uint32_t token)
{
	wl_proxy_marshal_flags((struct wl_proxy *) xdg_popup,
			 XDG_POPUP_REPOSITION, NULL, wl_proxy_get_version((struct wl_proxy *) xdg_popup), 0, positioner, token);
}

#ifdef  __cplusplus
}
#endif

#endif
